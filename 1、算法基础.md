# 第一部分 算法基础

## 第一章 算法在计算中的作用

### 练习 1.1

**1.1-1 给出现实生活中需要排序的一个例子或者现实生活中需要计算凸壳的一个例子。**

排序的例子：
	学生成绩排序：学校在发布成绩时，需要对学生的成绩进行排序，以便确定排名，或者筛选出成绩最高或最低的学生。这种排序常用于奖学金评定、班级排名等。

银行账单排序：在银行系统中，经常需要对客户的交易进行排序，特别是在生成账单或者报表时。例如，按照交易金额从高到低，或者按照交易时间排序，以便分析用户的消费习惯或处理异常交易。

快递派送排序：快递公司在派送包裹时，通常会根据送货地址和时间进行排序，确保物流最优，节省运输成本。比如，按照地理位置将包裹分配给不同的配送员，或者通过距离和交通状况优化路线。

医疗排队系统：在医院，患者根据病情的紧急程度、就诊时间等因素进行排序。对于急诊患者，会优先处理；对于预约患者，会根据预约时间和科室进行排序安排。

电影票销售排序：在在线票务平台上，电影票的销量和座位安排也需要排序。根据观众的选择，优先处理热门场次或热销座位。

计算凸壳的例子：
	机器人路径规划：在机器人技术中，尤其是自主导航和避障时，计算凸壳可以帮助确定一个区域内的可行路径。例如，机器人需要避开障碍物并寻找最短的路径，计算凸壳有助于确定机器人的运动边界。

农田边界确定：在农业中，农田的边界需要根据不同地点的土地特征来确定。在这种情况下，使用凸壳算法来计算农田的最小外接多边形，可以有效地描述农田的区域。

计算城市建筑物的外轮廓：在城市规划和建筑物管理中，计算一组建筑物外轮廓的凸壳，可以帮助规划人员分析城市的空间布局和区域的利用率，进一步优化城市结构。

地质勘探中的岩石分布：在地质勘探中，研究员通常会记录岩石的不同样本位置，并计算出岩石样本的凸壳，以帮助确定矿藏的分布区域。

计算点集的最小包围多边形：在一些图形学应用中，尤其是计算几何学中，需要计算一组点的凸壳。例如，在图像处理、物体识别中，常常会通过凸壳算法来简化对象的外部形状，进而进行进一步的分析。

**1.1-2 除速度外，在真实环境中还可能使用哪些其他有关效率的量度？** 

1. 空间复杂度（Space Complexity）
描述：空间复杂度衡量的是算法执行过程中需要使用的内存量或存储空间。它通常依赖于输入数据的大小，并且在实际应用中，内存资源可能比处理速度更加紧张。
实例：在处理大数据集时，如果算法需要占用大量内存（如递归调用堆栈或存储大量中间结果），这可能会导致内存溢出或系统资源耗尽，影响实际执行。

2. 能耗（Energy Consumption）
描述：在现代计算环境中，尤其是在移动设备、嵌入式系统和大规模数据中心，能耗是一个非常重要的效率量度。不同的算法和实现可能消耗不同量的电力，影响设备的电池寿命或运行成本。
实例：在移动设备中，低能耗算法（例如减少计算量、避免频繁的数据传输）能延长电池使用时间；在云计算中，高效能耗的算法可以减少数据中心的电力消耗和冷却需求。
3. 输入/输出 (I/O) 操作次数
描述：I/O 操作指的是与外部存储介质（如磁盘、网络）之间的读写操作。在实际应用中，算法的效率不仅取决于 CPU 处理速度，还取决于如何高效地处理数据的输入和输出。
实例：在数据库查询中，频繁的磁盘读取和写入操作可能会导致性能瓶颈，因此优化 I/O 操作（例如使用缓存、减少不必要的磁盘访问）是提高效率的关键。
4. 可扩展性（Scalability）
描述：可扩展性指的是算法在处理更大规模数据时，能保持或较小的增幅的效率变化。在大数据环境中，能够有效扩展的算法比在小数据集下表现良好的算法更重要。
实例：分布式计算算法需要能够有效扩展，随着节点数的增加，性能不应线性下降或遭遇过度瓶颈。
5. 延迟（Latency）
描述：延迟衡量的是从请求到响应所需要的时间。在实时系统中，低延迟是至关重要的，例如在自动驾驶、在线游戏或视频流媒体中。
实例：低延迟算法可以确保实时反馈，例如在金融交易平台，秒级延迟可能影响交易结果，要求算法在最低的时间内处理请求。
6. 吞吐量（Throughput）
描述：吞吐量是单位时间内完成的工作量。在很多情况下，高吞吐量意味着系统能在单位时间内处理更多的请求或数据。
实例：在网络传输或数据处理场景中，吞吐量越高，表示系统可以处理更多的数据量，比如高吞吐量的数据传输协议可以确保视频流媒体在不间断的情况下播放。
7. 稳定性（Stability）
描述：稳定性指的是算法在面对输入变化或扰动时，能够保持一致的性能和结果。稳定性尤其重要在处理海量数据或噪声数据时。
实例：在排序算法中，稳定排序意味着相等元素的相对顺序不发生变化。在其他场景中，算法的稳定性能够确保无论数据变化如何，算法的输出始终如一。
8. 并发性（Concurrency）
描述：并发性衡量的是算法能否有效地在多个计算单元（如多核 CPU、分布式系统等）上并行执行。在处理大型任务时，良好的并发性能够提高整体效率。
实例：大规模数据处理任务如图像处理、数据分析等，通过并行化可以显著提高处理速度，减少整体运行时间。
9. 算法的实现复杂度（Implementation Complexity）
描述：实现复杂度是指实现一个算法所需的开发时间、代码的复杂度以及调试难度。在某些项目中，尽管某些算法理论上效率高，但如果其实现复杂且容易出错，可能会选择更简单的替代方案。
实例：某些高效的排序算法（如快速排序）可能需要较高的实现复杂度，而简单的排序算法（如冒泡排序）虽然效率较低，但易于实现和调试，适合小规模数据。
10. 容错性（Fault Tolerance）
描述：容错性指的是算法在面对异常情况、错误或失效时的表现。具有良好容错性的算法可以在某些部分失败时，仍然能够继续工作并减少损失。
实例：在分布式系统中，算法的容错性确保即使部分计算节点失效，系统依然能够正确完成任务。此类算法在高可用性要求下非常重要。

**1.1-3 选择一种你以前巳知的数据结构，并讨论其优势和局限。** 

以哈希表为例，哈希表是一种常见的数据结构，它通过哈希函数将数据映射到一个表格（数组）中，以支持高效的查找、插入和删除操作。

哈希表的优势：

1. 查找效率高（常数时间复杂度）：
   - 哈希表在理想情况下，查找操作的时间复杂度是 $O(1)$。这是因为哈希函数直接将键值映射到数组的索引上，能够快速定位到元素。
   - 相比于线性数据结构（如链表或数组），哈希表的查找效率大大提高，尤其是在数据量很大的情况下。
2. 插入和删除操作高效：
   - 插入和删除操作的平均时间复杂度也是 $O(1)$，这使得哈希表在需要频繁更新数据的场景下非常有用。
3. 灵活的键值映射：
   - 哈希表支持将任意类型的对象（如字符串、数字等）作为键（Key），通过哈希函数将这些键映射到数组索引上，这使得哈希表具有较强的通用性。
4. 适用于快速查找应用：
   - 哈希表非常适合用在需要快速查找的数据应用中。例如，数据库索引、缓存机制等，它能够通过唯一的键值对数据进行快速定位。
5. 低内存开销：
   - 相较于其他数据结构（如树或链表），哈希表的内存开销较低，特别是在通过合适的哈希函数避免冲突时，内存的使用更加高效。

哈希表的局限性：

1. 哈希冲突（Hash Collision）：
   - 哈希表的主要局限性是哈希冲突。当两个不同的键被哈希到相同的索引位置时，就会发生冲突。为了处理冲突，通常需要使用开放地址法或链表法等方法，但这些方法可能会影响性能，特别是在哈希表负载较高时。
2. 对哈希函数的依赖：
   - 哈希表的性能高度依赖于哈希函数的设计。一个不好的哈希函数可能导致大量冲突，从而导致查找、插入、删除操作的时间复杂度退化为 $O(n)$，使得哈希表的优势无法发挥。
3. 不适合按顺序遍历：
   - 哈希表并不保持元素的顺序。如果需要按插入顺序或某种排序顺序来遍历数据，哈希表就不适用了。虽然可以用链表法来解决这一问题，但这样会影响其时间复杂度。
4. 内存空间问题：
   - 哈希表可能会占用比实际数据更大的内存，尤其是在需要避免哈希冲突时，可能需要扩展哈希表的大小，导致内存浪费。为保持高效，通常需要进行负载因子的管理。
5. 不适合范围查询：
   - 哈希表非常适合单一键值的查找，但不适合执行范围查询。例如，要查找一个范围内的所有元素，哈希表并不提供直接的支持，因此在需要进行范围查询的场景中，其他数据结构（如平衡二叉搜索树）可能更合适。

结论：哈希表是一种高效的查找、插入和删除数据的数据结构，在很多应用中都有广泛的使用，尤其是在需要频繁访问、快速查找数据的场景。然而，哈希表也有一些局限性，特别是在哈希冲突、排序和范围查询等方面。因此，在实际使用时，需要根据具体问题的需求来选择是否使用哈希表，并确保哈希函数的设计足够合理。

**1.1-4 前面给出的最短路径与旅行商问题有哪些相似之处？又有哪些不同？** 

最短路径问题（Shortest Path Problem）和旅行商问题（Travelling Salesman Problem，TSP）是两类经典的优化问题，它们有一些相似之处，但也存在显著的不同。下面是它们的相似之处和不同之处：

相似之处：

1. 图论基础：
   - 最短路径问题和旅行商问题都属于图论中的问题，涉及图的顶点（节点）和边（连接节点的路径）。
   - 两个问题都假设图是由顶点和边构成的，边上有权重（代表距离、时间、费用等）。

2. 路径优化：
   - 两个问题都要求找到最优路径。最短路径问题要求在图中找到两个特定节点之间的最短路径，而旅行商问题要求找一条最短的路径使得旅行商能够访问图中所有的节点并且返回到起始节点。
   - 都涉及“路径”的计算，目标是优化路径的某个属性（最短路径或最小总距离）。

3. 贪心策略和动态规划应用：
   - 这两个问题在求解过程中都可以应用动态规划或贪心策略的思想。虽然两者的具体解法不同，但都可以采用近似算法或最优解法来求解。

4. 计算复杂度高：
   - 最短路径问题和旅行商问题在大规模图上求解时都面临计算复杂度较高的问题。特别是旅行商问题是一个 $NP-hard$ 问题，而最短路径问题虽然在某些情况下可以通过高效算法解决（例如 Dijkstra 算法、Bellman-Ford 算法），但在复杂的场景下也可能变得计算密集。

不同之处：

1. 问题目标：
   - 最短路径问题：目标是找到一个起点到终点的最短路径，通常解决的是从一个固定节点到另一个固定节点的最短路径。
   - 旅行商问题（TSP）：目标是找到一个 ==最短的闭环路径==（即从起点出发，访问所有节点一次并返回起点），因此它要求遍历图中的所有节点，并且路径是一个回路。

2. 路径的约束：
   - 最短路径问题：通常只涉及从一个起点到一个终点的路径，不需要访问所有节点，路径的长度是优化目标。
   - 旅行商问题（TSP）：要求访问图中所有的节点一次且仅一次，必须形成一个回路（即从起点出发，最终返回到起点），这是其约束条件之一。

3. 解的规模：
   - 最短路径问题：解决的目标通常是起点到终点之间的单一最短路径，只考虑这两个节点之间的最短路线。
   - 旅行商问题（TSP）：解决的是一个包含多个节点的路径问题，解决方案是一个包含所有节点的路径，规模更大，且可能具有指数级的复杂性。

4. 计算复杂度：
   - 最短路径问题：有多种高效的算法可以求解，如 Dijkstra 算法、Bellman-Ford 算法等，时间复杂度通常是 $(O(E \log V))$（其中 $(E)$ 是边数，$(V)$ 是节点数）。
   - 旅行商问题（TSP）：是一个 NP-hard 问题，意味着在多项式时间内无法找到精确解。常见的求解方式是穷举法（暴力搜索）、分支限界法、启发式算法（如遗传算法、模拟退火等），这些算法通常只能提供近似解，计算复杂度较高。

5. 是否返回起点：
   - 最短路径问题：并不要求路径形成一个回路，通常是从起点到终点的最短路径。
   - 旅行商问题（TSP）：必须返回起点，即路径必须形成一个闭环。

6. 实例应用不同：
   - 最短路径问题：应用场景包括 ==地图导航、网络数据包传输、物流调度== 等，需要快速找到从一个地点到另一个地点的最短路径。
   - 旅行商问题（TSP）：应用场景包括 ==快递配送路线优化、旅游线路设计、生产调度问题== 等，解决的是多个地点的遍历问题，常见于需要遍历多个节点并返回起点的情况。

总结：

- 相似性：最短路径问题和旅行商问题都与图的遍历有关，且目标都是最小化路径的某种特性（如距离、时间等），都属于优化问题，并且在计算复杂度方面都有挑战。
- 差异性：最短路径问题关注的是从起点到终点的路径，而旅行商问题要求遍历所有节点并返回起点，且旅行商问题通常具有更高的计算复杂度。

**1.1-5 提供一个现实生活的间题，其中只有最佳解才行。然后提供一个问题，其中近似最佳的一个解也足够好。**

现实生活中只有最佳解才行的问题：

医疗手术调度问题： 在医院的手术室调度中，手术室资源是有限的，手术需要根据优先级、患者健康状况以及手术复杂度来安排。尤其是对于急需手术的病人（如急诊病人、癌症患者等），如果手术调度不当，可能会危及患者的生命安全。

- 为什么需要最佳解？ 在这种情况下，只有最佳解能确保所有病人在最佳时间得到手术，避免不必要的延误，保障患者生命安全。
- 例子：如果需要安排多个患者的手术，错过手术的最佳时间可能会导致患者病情加重甚至死亡，这时候近似的解决方案无法满足实际需求。

现实生活中近似最佳解也足够好的问题：

广告竞价问题： 在广告投放平台（如谷歌广告、Facebook 广告）中，广告商为其广告位进行竞价。广告商的目标是最大化广告的点击率（CTR）或转化率（Conversion Rate），并且通常会根据预算限制在特定的时间段内投放广告。

- 为什么近似解足够好？ 在这个问题中，广告竞价的目标是优化广告的投放效果，然而完全准确的最佳解可能无法在合理时间内计算出来，且即使是一个“近似”解，也能显著提升广告效果并保证合理的投入产出比。
- 例子：广告商通常使用启发式算法或近似算法来选择最佳的投放位置、预算分配等。即使没有完全最优的解，得到了一个“近似最佳”的解，也能够带来足够好的投资回报率，因此近似解在此类应用中足够好。

总结：

- 最佳解：通常适用于一些具有高精度要求、直接关系到安全或质量的领域，如医疗、航天等。
- 近似解：适用于一些可以容忍一定误差且效率要求较高的场景，如广告竞价、物流配送等。

### 练习 1.2

**1.2-1 给出在应用层需要算法内容的应用的一个例子，并讨论涉及的算法的功能。**

应用层需要算法内容的应用示例：推荐系统

背景：

推荐系统被广泛应用于电子商务平台（如亚马逊、淘宝）、流媒体平台（如 Netflix、YouTube）、社交媒体（如 Facebook、Instagram）等领域。其主要功能是根据用户的历史行为和偏好，向用户推荐他们可能感兴趣的商品、视频、朋友或其他内容。

涉及的算法及功能：

1. 协同过滤算法（Collaborative Filtering）：

   - 功能

     ：协同过滤是推荐系统中最常用的算法之一。它的基本思想是通过分析用户与用户、商品与商品之间的相似性，来进行推荐。协同过滤有两种主要类型：基于用户的协同过滤和基于物品的协同过滤。

     - 基于用户的协同过滤：通过查找与当前用户兴趣相似的其他用户，推荐这些相似用户喜欢的物品。
     - 基于物品的协同过滤：通过分析用户历史上喜欢的物品，推荐与这些物品相似的其他物品。

   - 应用场景：例如，Netflix 推荐你看《黑镜》是基于其他用户看过《黑镜》并且喜欢类似影片的行为。

2. 内容推荐算法（Content-Based Filtering）：

   - 功能：内容推荐算法根据物品本身的属性（如商品的种类、价格、标签，视频的导演、演员、类型等）来进行推荐。这种方法分析用户对某一类物品的兴趣，并推荐与这些物品相似的其他物品。
   - 应用场景：例如，YouTube 根据你过去观看的视频内容、标签和描述，推荐与你之前观看的视频类型相似的视频。

3. 矩阵分解算法（Matrix Factorization）：

   - 功能：矩阵分解是一种用于降维的技术，通常用于将用户-物品的评分矩阵分解成两个低维矩阵，从而捕捉到用户和物品之间潜在的特征关系。常见的算法有 SVD（奇异值分解）和 ALS（交替最小二乘法）。
     - SVD：将用户-物品评分矩阵分解为用户矩阵、物品矩阵和一个对角矩阵。通过这些矩阵的乘积来预测用户对未评分物品的评分。
   - 应用场景：如在亚马逊或 Netflix 上，系统通过矩阵分解算法推荐用户可能喜欢的商品或电影，基于用户历史的评分和行为来进行预测。

4. 深度学习推荐算法（Deep Learning-Based Recommendations）：

   - 功能：深度学习方法（如神经网络、卷积神经网络、循环神经网络等）通过处理更复杂的数据，捕捉更深层次的用户兴趣和物品特征。近年来，深度学习在推荐系统中的应用越来越广泛，尤其是在处理大规模数据和复杂用户行为模式时表现优异。
   - 应用场景：例如，Netflix 使用深度学习来分析用户观看的历史记录，并根据用户的观看行为（如暂停、跳过、重复观看等）做出精准推荐。

5. 强化学习算法（Reinforcement Learning）：

   - 功能：强化学习在推荐系统中的应用通过模拟一个智能体与环境的交互，智能体根据反馈（如用户的点击、观看、购买等行为）调整其推荐策略。与传统的监督学习方法不同，强化学习通过奖惩机制优化推荐策略。
   - 应用场景：例如，在电商平台中，基于用户的实时行为（如浏览、点击、购买）动态调整推荐内容，提高推荐的相关性和用户满意度。

总结：推荐系统是一个典型的应用层需要算法的案例，它集成了多种算法（如协同过滤、矩阵分解、深度学习等），通过分析用户行为、物品特征和交互数据，向用户推荐个性化的内容。推荐系统的目标是提升用户体验，提高平台的用户粘性和商业转化率。每种算法在推荐系统中承担着不同的任务和功能，通过相互配合，帮助系统为用户提供最相关、最精确的推荐内容。

**1.2-2 假设我们正比较插入排序与归并排序在相同机器上的实现。对规模为 $n$ 的输入，插入排序运行 $8n^2$ 步，而归并排序运行 $64n \lg n$ 步。问对哪些 $n$ 值，插入排序优于归并排序？**

插入排序优于归并排序，也就是解不等式：
$$
8n^2 < 64n \lg n
$$
解得：$n<8 \lg n$，也就是，满足该条件则插入排序更优，否则归并排序更优；说明实际应用中选择算法不能简单看算法的渐进复杂度的优劣，更要看应用场景和问题规模，依据实际情况选择最合适的算法

1.2-3 $n$ 的最小值为何值时，运行时间为 $100n^2$ 的一个算法在相同机器上快于运行时间为 $2^n$ 的另一个算法？

解不等式：
$$
100n^2 < 2^n
$$
解得：

### 思考题

**1-1 (运行时间的比较) 假设求解问题的算法需要 $f(n)$ 毫秒，对下表中的每个函数 $f(n)$ 和时间 $t$, 确定可以在时间 $t$ 内求解的问题的最大规模 $n$。**

解：按照一个月 30 天计算：

1 秒钟 = $1000ms$	1 分钟 = $6\times 10^4ms$	1 小时 = $3.6\times 10^6ms$	1 天 = $8.64 \times 10^7ms$	

1 月 = $2.592\times 10^9ms$	1 年 = $3.1104\times 10^{10}ms$	1 世纪 = $3.1104\times 10^{12}ms$

相当于解不等式，给定 $t$，求满足 $f(n)<t$ 的最大 $n$

|            | 1 秒钟 | 1 分钟 | 1 小时 | 1 天  | 1 月  | 1 年  | 1 世纪 |
| :--------: | :---: | :---: | :---: | :--: | :--: | :--: | :---: |
|  $\lg n$   | $\lfloor e^{1000}\rfloor$ |       |       |      |      |      |       |
| $\sqrt{n}$ | 10^6 |       |       |      |      |      |       |
|    $n$     | 10^3 |       |       |      |      |      |       |
|  $n\lg n$  | 190 |       |       |      |      |      |       |
|   $n^2$    | 31 |       |       |      |      |      |       |
|   $n^3$    | 10 |       |       |      |      |      |       |
|   $2^n$    | 9 |       |       |      |      |      |       |
|    $n!$    | 6 |       |       |      |      |      |       |

## 第二章 算法基础

### 练习 2.1

**2.1-1 以图 2-2 为模型，说明 INSERTION-SORT 在数组 $A=(31, 41, 59, 26, 41, 58)$ 上的执行过程。**

图2-2如下：展示了插入排序的执行过程

![image-20250121215626567](F:\software\Typora\images\image-20250121215626567.png)

对于数组A=（31，41，59，26，41，58），插入排序的执行过程如下，从第二个元素开始，依次判断当前元素和前一个元素的大小关系，如果当前元素更大，则不做处理；如果当前元素更小，则交换当前元素和前一个元素，直到当前元素所在位置左边的元素比它小或当前元素左边没有元素为止。

执行过程如下：

| 处理位置 | 判断结果 |            处理结果            |
| :------: | :------: | :----------------------------: |
|    2     |  41>31   | （31，**41**，59，26，41，58） |
|    3     |  59>41   | （31，**41**，59，26，41，58） |
|    4     |  26<59   | （31，**41**，26, 59，41，58） |
|    4     |  26<41   | （31，26, **41**, 59，41，58） |
|    4     |  26<31   | （26, 31, **41**, 59，41，58） |
|    5     |  41<59   | （26, 31, **41**, 41, 59，58） |
|    6     |  58<59   | （26, 31, **41**, 41, 58, 59） |

**2.1-2 重写过程 INSERTION-SORT, 使之按非升序（而不是非降序）排序。** 

非升序的INSERTION-SORT伪代码如下：

```c
INSERTION-SORT(A) 
	for j = 2 to A. length 
		key= A[j] 
		// Insert A[j] into the sorted sequence A[1...j —1]. 
		i=j-1 
       // key表示当前待移动元素
		while i > 0 and A[i] < key 	// 如果当前元素大于前一个元素则交换位置，也就是将较大元素移到前面位置
			A[i+1] = A[i] 
			i=i-1 
		A[i+1] = key
```

**2.1-3 考虑以下查找问题： 输入：$n$ 个数的一个序列 $A=(a_1, a_2, …, a_n)$ 和一个值 $v$。 输出：下标 $i$ 使得 $v=A[i]$ 或者当 $v$ 不在 $A$ 中出现时，$v$ 为特殊值 NULL。 写出线性查找的伪代码，它扫描整个序列来查找 $v$。使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要的性质。** 

线性查找的伪代码如下：

```c
Linear_Find(A, v)
    for i = 1 to A.length
        if v==A[i]
            return i
    return NULL
```

2.1-4 考虑把两个 $n$ 位二进制整数加起来的问题，这两个整数分别存储在两个 $n$ 元数组 $A$ 和 $B$ 中。这两个整数的和应按二进制形式存储在一个(n+1)元数组 $C$ 中。请给出该问题的形式化描述，并写出伪代码。

### 练习 2.2

2.2-1 用 $\Theta$ 记号表示函数 $n^3/1000-100n^2 -100n+3$

2.2-2 考虑排序存储在数组 $A$ 中的 $n$ 个数：首先找出 $A$ 中的最小元素并将其与 $A[1]$ 中的元素进行交换。接着，找出 $A$ 中的次最小元素并将其与 $A[2]$ 中的元素进行交换。对 A 中前 $n-1$ 个元素按该方式继续。该算法称为 **选择算法**，写出其伪代码。该算法维持的循环不变式是什么？为什么它只需要对前 $n—1$ 个元素，而不是对所有 $n$ 个元素运行？用 $\Theta$ 记号给出选择排序的最好情况与最坏情况运行时间。

2.2-3 再次考虑线性查找问题（参见练习 2.1-3)。假定要查找的元素等可能地为数组中的任意元素，平均需要检查输入序列的多少元素？最坏情况又如何呢？用 $\Theta$ 记号给出线性查找的平均情况和最坏情况运行时间。证明你的答案。

2.2-4 我们可以如何修改几乎任意算法来使之具有良好的最好情况运行时间？

### 练习 2.3

2.3-1 使用图 2-4 作为模型，说明归并排序在数组 $A=\langle3,41,52,26,38,57,9,49\rangle$ 上的操作。

2.3-2 重写过程 MERGE, 使之不使用哨兵，而是一旦数组 $L$ 或 $R$ 的所有元素均被复制回 $A$ 就
立刻停止，然后把另一个数组的剩余部分复制回 $A$。

2.3-3 使用数学归纳法证明：当 $n$ 刚好是 2 的幂时，以下递归式的解是 $T(n)=n\lg n$ 。
$$
T(n)=\begin{cases}2&\text{若 }n = 2\\2T(n/2)+n&\text{若 }n = 2^k, k > 1\end{cases}
$$
2.3-4 我们可以把插人排序表示为如下的一个递归过程。为了排序 $A[1..n]$, 我们递归地排序 $A[1\ldots n-1]$, 然后把 $A[n]$ 插人已排序的数组 $A[1\ldots n-1]$。为插人排序的这个递归版本的最坏情况运行时间写一个递归式。

2.3-5 回顾查找问题(参见练习 2.1-3), 注意到，如果序列 $A$ 已排好序，就可以将该序列的中点与 $v$ 进行比较。根据比较的结果，原序列中有一半就可以不用再做进一步的考虑了。二分查找算法重复这个过程，每次都将序列剩余部分的规模减半。为二分查找写出迭代或递归的伪代码。证明：二分查找的最坏情况运行时间为 $\Theta(\lg n)$。

2.3-6 注意到 2.1 节中的过程 INSERTION-SORT 的第 5~7 行的 while 循环采用一种线性查找来(反向)扫描已排好序的子数组 $A[1\ldots j一1]$。我们可以使用二分查找(参见练习 2.3-5)来把插人排序的最坏情况总运行时间改进到 $\Theta(n\lg n)吗？$

$^* $ 2.3-7 描述一个运行时间为 $\Theta(n\lg n)$ 的算法，给定 $n$ 个整数的集合 $S$ 和另一个整数 $x$, 该算法能
确定 $S$ 中是否存在两个其和刚好为 $x$ 的元素。

### 思考题

2-1 (在归并排序中对小数组采用插入排序） 虽然归并排序的最坏情况运行时间为 $\Theta (nlgn)$, 而插入排序的最坏情况运行时间为 $\Theta (n^2)$, 但是插人排序中的常量因子可能使得它在 $n$ 较小 时，在许多机器上实际运行得更快。因此，在归并排序中当子问题变得足够小时，采用插入排序来使递归的叶变粗是有意义的。考虑对归并排序的一种修改，其中使用插入排序来 排序长度为 $k$ 的 $n/k$ 个子表，然后使用标准的合并机制来合并这些子表，这里 $k$ 是一个待定的值

a.证明：插入排序最坏情况可以在 $\Theta (nk)$ 时间内排序每个长度为 $K$ 的 $n/k$ 个子表。 

b.表明在最坏情况下如何在 $\Theta(nlg(n/k))$ 时间内合并这些子表。 

c.假定修改后的算法的最坏情况运行时间为 $\Theta(nk+nlg(n/k))$, 要使修改后的算法与标准的归并排序具有相同的运行时间，作为 $n$ 的一个函数，借助 $\Theta$ 记号，$K$ 的最大值是什么？ 

d. 在实践中，我们应该如何选择 $k$?



2-2 (冒泡排序的正确性) 冒泡排序是一种流行但低效的排序算法，它的作用是反复交换相邻
的未按次序排列的元素。

**BUBBLESORT(A)** 

```c
for i = 1 to A.length - 1 
	for j = A.length downto i + 1 
		if A[j] < A[j —1] 
			exchange A[j] with A[j —1] 
```

a.假设 $A^\prime$​表示 BUBBLESORT(A)的输出。为了证明 BUBBLESORT 正确，我们必须证明它将终止并且有：
$$
A^{\prime}[1]\leqslant A^{\prime}[2]\leqslant\cdotp\cdotp\cdotp\leqslant A^{\prime}[n]	\tag{2.3}
$$
其中 $n=A.length$。为了证明 BUBBLESORT 确实完成了排序，我们还需要证明什么？下面两部分将证明不等式(2.3)。

b.为第 2~4 行的 for 循环精确地说明一个循环不变式，并证明该循环不变式成立。你的证
明应该使用本章中给出的循环不变式证明的结构。

c 使用(b)部分证明的循环不变式的终止条件，为第 1~4 行的 for 循环说明一个循环不变
式，该不变式将使你能证明不等式(2.3)。你的证明应该使用本章中给出的循环不变式证
明的结构。

d.冒泡排序的最坏情况运行时间是多少？与插人排序的运行时间相比，其性能如何？



2-3 (霍纳(Horner)规则的正确性) 给定系数 $a_0,a_1,...,a_n$ 和 $x$ 的值，代码片段

```
y= 0 
for i = n downto 0 
	y = a_i + x*y 
```


实现了用于求值多项式

$$
P(x)=\sum_{k = 0}^na_kx^k = a_0+x(a_1+x(a_2+\cdotp\cdotp\cdotp+x(a_{n-1}+xa_n)\cdotp\cdotp\cdotp))
$$
的霍纳规则。

a.借助 $\Theta$ 记号，实现霍纳规则的以上代码片段的运行时间是多少？

b.编写伪代码来实现朴素的多项式求值算法，该算法从头开始计算多项式的每个项。该算法的运行时间是多少？与霍纳规则相比，其性能如何？

c.考虑以下循环不变式：在第 2~3 行 for 循环每次迭代的开始有
$$
y =\sum_{k = 0}^{n-(i+1)}a_{k+i+1}x^k
$$
把没有项的和式解释为等于 0。遵照本章中给出的循环不变式证明的结构，使用该循环不变式来证明终止时有 $y=\sum\limits_{k=0}^n a_k x^k$

d. 最后证明上面给出的代码片段将正确地求由系数 $a_0,a_1,...,a_n$ 刻画的多项式的值。



2-4 (逆序对) 假设 $A[1..n]$ 是一个有 $n$ 个不同数的数组。若 $i<j$ 且 $A[i]{>}A[j]$，则对偶($i$, $j$)称为
$A$ 的一个逆序对(inversion)。

a.列出数组 ${\langle2,3,8,6,1\rangle}$ 的 5 个逆序对。

b.由集合{1,2,..., n}中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？

c.插人排序的运行时间与输入数组中逆序对的数量之间是什么关系？证明你的回答。

d.给出一个确定在 $n$ 个元素的任何排列中逆序对数量的算法，最坏情况需要 $\Theta(n\lg n)$ 时间。(提示：修改归并排序。)



## 第三章 函数的增长

### 练习 3.1

3.1-1 假设 $f(n)$ 与 $g(n)$ 都是渐近非负函数。使用 $\Theta$ 记号的基本定义来证明 $max(f(n),g(n))=\Theta(f(n)+g(n))$

3.1-2 证明：对任意实常量 $a$ 和 $b$, 其中 $b$ > 0, 有
$$
(n+a)^b =\Theta(n^b)	\tag{3.2}
$$
3.1-3 解释为什么“算法 $A$ 的运行时间至少是 $O(n^2)$”这一表述是无意义的。

3.1-4 $2^{n+ 1}= O( 2^n)$ 成立吗？$2^{2n}=O(2^n)$ 成立吗？

3.1-5 证明定理 3.1。

3.1-6 证明：一个算法的运行时间为 $\Theta(g(n))$ 当且仅当其最坏情况运行时间为 $O(g(n))$, 且其最好情况运行时间为 $\Omega(g(n))$。

3.1-7 证明：$o(g(n))\bigcap \omega(g(n))$ 为空集。

3.1-8 可以扩展我们的记号到有两个参数 $n$ 和 $m$ 的情形，其中的 $n$ 和 $m$ 可以按不同速率独立地趋于无穷。对于给定的函数 $g(n,m)$，用 $O(g(n,m))$ 来表示以下函数集：
$$
O(g(n, m))=\left\{f(n, m):\text{存在正常量 }c\text{、}n_0\text{和}m_0 , \text{使得对所有 }n\geq n_0\text{ 或 }m\geqslant m_0\right.，
\\有 0\leqslant f(n, m)\leqslant cg(n, m)\}
$$
对 $\Omega(g(n,m))$ 和 $\Theta(g(n,m))$ 给出相应的定义。



### 练习 3.2

3.2-1 证明：若 $f(n)$ 和 $g(n)$ 是单调递增的函数，则函数 $f(n)+g(n)$ 和 $f(g(n))$ 也是单调递增的，此外，若 $f(n)$ 和 $g(n)$ 是非负的，则 $f(n) \cdot g(n)$ 是单调递增的。

3.2-2 证明等式(3.16)

3.2-3 证明等式(3.19)，并证明 $n! =\omega(2^n)$ 且 $n! =o(n^n)$

*3.2-4 证明 $\lceil \lg n \rceil !$ 多项式有界吗？函数 $\lceil \lg \lg n \rceil !$ 多项式有界吗？

*3.2-5 如下两个函数中，哪个渐进更大些：$\lg(\lg^ * n)$ 还是 $\lg^*(\lg n)$

3.2-6 证明：黄金分割率 $\phi$ 及其共轭数 $\hat{\phi}$ 都满足方程 $x^2=x+1$

3.2-7 用归纳法证明：第 i 个斐波拉契数满足等式
$$
F_i =\frac{\phi^i-\hat{\phi^i}}{\sqrt{5}}
$$
其中 $\phi$ 是黄金分割率且 $\hat{\phi}$ 是其共轭数

3.2-8 证明：$k \ln k=\Theta(n)$ 蕴含着 $k=\Theta(n/ \ln n)$

### 思考题

3.1 （多项式的渐进行为） 假设 $p(n)=\sum\limits_{i=0}^d a_in^i$ 是一个关于 $n$ 的 $d$ 次多项式，其中 $a_d>0$，$k$ 是一个常量。使用渐进符号的定义来证明下面的性质。

​	a.若 $k\ge d$，则 p(n)= O(n^k)

​	b.若 $k\le d$，则 $p(n)=\Omega(n^k)$

​	c.若 $k=d$，则 $p(n)=\Theta(n^k)$

​	d.若 $k>d$，则 $p(n)=o(n^k)$

​	e.若 $k<d$，则 $p(n)=\omega(n^k)$

3.2 （相对渐进增长）为下表中的每对表达式 $(A, B)$ 指出 $A$ 是否是 $B$ 的 O、o、$\Omega$、$\omega$ 或 $\Theta$。假设 $k\ge 1$、$\epsilon>0$ 且 $c>1$ 均为常量。回答应该以表格的形式，将“是”或“否”写在每个空格中。

|      |      A      |      B       |  O   |  o   | $\Omega$ | $\omega$ | $\Theta$ |
| :--: | :---------: | :----------: | :--: | :--: | :------: | :------: | :------: |
|  a.  |  $\lg^k n$  | $n^\epsilon$ |      |      |          |          |          |
|  b.  |    $n^k$    |    $c^n$     |      |      |          |          |          |
|  c.  | $\sqrt{n}$  | $n^{\sin n}$ |      |      |          |          |          |
|  d.  |    $2^n$    |  $2^{n/2}$   |      |      |          |          |          |
|  e.  | $n^{\lg c}$ | $c^{\lg n}$  |      |      |          |          |          |
|  f.  |  $\lg(n!)$  |  $\lg(n^n)$  |      |      |          |          |          |

3-3 （根据渐近增长率排序）

a. 根据增长的阶来排序下面的函数，即求出满足 $g_1 = \Omega(g_2), g_2 = \Omega(g_3), \cdots, g_{29} = \Omega(g_{30})$ 的函数的一种排列 $g_1, g_2, \cdots, g_{30}$。把你的表划分成等价类，使得函数 $f(n)$ 和 $g(n)$ 在相同类中当且仅当 $f(n) = \Theta(g(n))$。

$$
\begin{array}{cccccccc}
\lg(\lg^* n) & 2^{\lg^* n} & (\sqrt{2})^{\lg n} & n^2 & n! & (\lg n)! \\
\left(\frac{3}{2}\right)^n & n^3 & \lg^2 n & \lg(n!) & 2^{2^n} & n^{1/\lg n} \\\ln \ln n& \lg^* n & n \cdot 2^n & n^{\lg \lg n} & \ln n & 1\\
2^{\lg n} & (\lg n)^{\lg n} & e^n & 4^{\lg n} & (n+1)! & \sqrt{\lg n} \\
\lg^*(\lg n) & 2^{\sqrt{2 \lg n}} & n & 2^n & n \lg n & 2^{2^{n+1}} \\
\end{array}
$$
b. 给出非负函数 $f(n)$ 的一个例子，使得对所有在(a)部分中的函数 $g_i(n)$，$f(n)$ 既不是 $O(g_i(n))$ 也不是 $\Omega(g_i(n))$。



3-4 （渐近记号的性质）假设 $f(n)$ 和 $g(n)$ 为渐近正函数。证明或反驳下面的每个猜测。

​	a. $f(n) = O(g(n))$ 蕴涵 $g(n) = O(f(n))$。

​	b. $f(n) + g(n) = \Theta(\min(f(n), g(n)))$。

​	c. $f(n) = O(g(n))$ 蕴涵 $\lg(f(n)) = O(\lg(g(n)))$，其中对所有足够大的 $n$，有 $\lg(g(n)) \geq 1$ 且 $f(n) \geq 1$。

​	d. $f(n) = O(g(n))$ 蕴涵 $2^{f(n)} = O(2^{g(n)})$。

​	e. $f(n) = O((f(n))^2)$。

​	f. $f(n) = O(g(n))$ 蕴涵 $g(n) = \Omega(f(n))$。

​	g. $f(n) = \Theta(f(n/2))$。

​	h. $f(n) + o(f(n)) = \Theta(f(n))$。

3-5 （O 与 Ω 的一些变形）某些作者用一种与我们稍微不同的方式来定义 Ω；假设我们使用 Ω̃（读作“Ω 无穷”）来表示这种可选的定义。若存在正常量 c，使得对无穷多个整数 n，有 $f(n) \geq c g(n) \geq 0$，则称 $f(n) = \tilde{\Omega}(g(n))$。

​	a. 证明：对渐近非负的任意两个函数 $f(n)$ 和 $g(n)$，或者 $f(n) = O(g(n))$ 或者 $f(n) = \tilde{\Omega}(g(n))$ 或者二者均成立，然而，如果使用 Ω 来代替 Ω̃，那么该命题并不为真。

​	b. 描述用 Ω 代替 Ω̃ 来刻画程序运行时间的潜在优点与缺点。

某些作者也用一种稍微不同的方式来定义 O；假设使用 $O'$ 来表示这种可选的定义。我们称 $f(n) = O'(g(n))$ 当且仅当 $|f(n)| = O(g(n))$。

​	c. 如果使用 $O'$ 代替 O 但仍然使用 Ω，定理 3.1 中的“当且仅当”的每个方向将出现什么情况？有些作者定义 $\tilde{O}$（读作“软 O''”）来意指忽略对数因子的 O：

$$
\tilde{O}(g(n)) = \{f(n): \text{存在正常量 } c, k \text{ 和 } n_0, \text{ 使得对所有 } n \geq n_0, \text{ 有 } 0 \leq f(n) \leq c g(n) \lg^k(n)\}
$$

d. 用一种类似的方式定义 $\tilde{\Omega}$ 和 $\tilde{\Theta}$。证明与定理 3.1 相对应的类似结论。

3-6 （多重函数）我们可以把用于函数 $\lg^*$ 中的重复操作符 * 应用于实数集上的任意单调递增函数 $f(n)$。对给定的常量 $c \in \mathbb{R}$，我们定义多重函数 $f_c^*$ 为
$$
f_c^*(n) = \min\{i \geq 0: f^{(i)}(n) \leq c\}
$$
该函数不必在所有情况下都为良定义的。换句话说，值 $f_c^*(n)$ 是为缩小其参数到 c 或更小所需要函数 f 重复应用的数目。

对如下每个函数 $f(n)$ 和常量 c，给出 $f_c^*(n)$ 的一个尽量紧确的界。

|   $f(n)$   |  c   | $f_c^*(n)$ |
| :--------: | :--: | :--------: |
|   $n-1$    |  0   |            |
|  $\lg n$   |  1   |            |
|   $n/2$    |  1   |            |
|   $n/2$    |  2   |            |
| $\sqrt{n}$ |  2   |            |
| $\sqrt{n}$ |  1   |            |
| $n^{1/3}$  |  2   |            |
| $n/\lg n$  |  2   |            |



## 第四章 分治策略

### 练习 4.1

4.1-1 当 $A$ 的所有元素均为负数时，FIND-MAXIMUM-SUBARRAY 返回什么？

4.1-2 对最大子数组问题，编写暴力求解方法的伪代码，其运行时间应该为 $\Theta(n^2)$。

4.1-3 在你的计算机上实现最大子数组问题的暴力算法和递归算法。请指出多大的问题规模 $n_0$ 是性能交叉点——从此之后递归算法将击败暴力算法？然后，修改递归算法的基本情况——当问题规模小于 $n_0$ 时采用暴力算法。修改后，性能交叉点会改变吗？

4.1-4 假定修改最大子数组问题的定义，允许结果为空子数组，其和为 0。你应该如何修改现有算法，使它们能允许空子数组为最终结果？

4.1-5 使用如下思想为最大子数组问题设计一个非递归的、线性时间的算法。从数组的左边界开始，由左至右处理，记录到目前为止已经处理过的最大子数组。若已知 $A[1..j]$ 的最大子数组，基于如下性质将解扩展为 $A[1..j+1]$ 的最大子数组：$A[1..j+1]$ 的最大子数组要么是 $A[1..j]$ 的最大子数组，要么是某个子数组 $A[i..j+1] (1 \leq i \leq j+1)$。在已知 $A[1..j]$ 的最大子数组的情况下，可以在线性时间内找出形如 $A[i..j+1]$ 的最大子数组。

### 练习 4.2

注意：虽然练习 4.2-3、4.2-4 和 4.2-5 是关于 Strassen 算法的变形的，但你应该先阅读 4.5 节，然后再尝试求解这几个问题。

4.2-1 使用 Strassen 算法计算如下矩阵乘法：
$$
\begin{bmatrix}
1 & 3 \\
7 & 5
\end{bmatrix}
\begin{bmatrix}
6 & 8 \\
4 & 2
\end{bmatrix}
$$
给出计算过程。

4.2-2 为 Strassen 算法编写伪代码。

4.2-3 如何修改 Strassen 算法，使之适应矩阵规模 n 不是 2 的幂的情况？证明：算法的运行时间为 $\Theta(n^{\lg 7})$。

4.2-4 如果可以用 k 次乘法操作（假定乘法的交换律不成立）完成两个 $3 \times 3$ 矩阵相乘，那么你可以在 $o(n^{\lg k})$ 时间内完成 $n \times n$ 矩阵相乘，满足这一条件的最大的 k 是多少？此算法的运行时间是怎样的？

4.2-5 V.Pan 发现一种方法，可以用 132 464 次乘法操作完成 $68 \times 68$ 的矩阵相乘，发现另一种方法，可以用 143 640 次乘法操作完成 $70 \times 70$ 的矩阵相乘，还发现一种方法，可以用 155 424 次乘法操作完成 $72 \times 72$ 的矩阵相乘。当用于矩阵相乘的分治算法时，上述哪种方法会得到最佳的渐近运行时间？与 Strassen 算法相比，性能如何？

4.2-6 用 Strassen 算法作为子进程来进行一个 $k n \times n$ 矩阵和一个 $n \times k n$ 矩阵相乘，最快需要花费多长时间？对两个输入矩阵规模互换的情况，回答相同的问题。

4.2-7 设计算法，仅使用三次实数乘法即可完成复数 $a+bi$ 和 $c+di$ 相乘。算法需接收 $a$、$b$、$c$ 和 $d$ 为输入，分别生成实部 $ac-bd$ 和虚部 $ad+bc$。

### 练习 4.3

4.3-1 证明：$T(n) = T(n-1) + n$ 的解为 $O(n^2)$。

4.3-2 证明：$T(n) = T(\lceil n/2 \rceil) + 1$ 的解为 $O(\lg n)$。

4.3-3 我们看到 $T(n) = 2T(\lfloor n/2 \rfloor) + n$ 的解为 $O(n \lg n)$。证明 $\Omega(n \lg n)$ 也是这个递归式的解。从而得出结论：解为 $\Theta(n \lg n)$。

4.3-4 证明：通过做出不同的归纳假设，我们不必调整归纳证明中的边界条件，即可克服递归式 (4.19) 中边界条件 $T(1) = 1$ 带来的困难。

4.3-5 证明：归并排序的“严格”递归式 (4.3) 的解为 $\Theta(n \lg n)$。

4.3-6 证明：$T(n) = 2T(\lfloor n/2 \rfloor + 17) + n$ 的解为 $O(n \lg n)$。

4.3-7 使用 4.5 节中的主方法，可以证明 $T(n) = 4T(n/3) + n$ 的解为 $T(n) = \Theta(n^{\log_3 4})$。说明基于假设 $T(n) \leqslant cn^{\log_3 4}$ 的代入法不能证明这一结论。然后说明如何通过减去一个低阶项完成代入法证明。

4.3-8 使用 4.5 节中的主方法，可以证明 $T(n) = 4T(n/2) + n$ 的解为 $T(n) = \Theta(n^2)$。说明基于假设 $T(n) \leqslant cn^2$ 的代入法不能证明这一结论。然后说明如何通过减去一个低阶项完成代入法证明。

4.3-9 利用改变变量的方法求解递归式 $T(n) = 3T(\sqrt{n}) + \log n$。你的解应该是渐近紧确的。不必担心数值是否是整数。

### 练习 4.4

4.4-1 对递归式 $T(n) = 3T(\lfloor n/2 \rfloor) + n$，利用递归树确定一个好的渐近上界，用代入法进行验证。

4.4-2 对递归式 $T(n) = T(n/2) + n^2$，利用递归树确定一个好的渐近上界，用代入法进行验证。

4.4-3 对递归式 $T(n) = 4T(n/2 + 2) + n$，利用递归树确定一个好的渐近上界，用代入法进行验证。

4.4-4 对递归式 $T(n) = T(n-1) + 1$，利用递归树确定一个好的渐近上界，用代入法进行验证。

4.4-5 对递归式 $T(n) = T(n-1) + T(n/2) + n$，利用递归树确定一个好的渐近上界，用代入法进行验证。

4.4-6 对递归式 $T(n) = T(n/3) + T(2n/3) + cn$，利用递归树论证其解为 $\Omega(n \lg n)$，其中 c 为常数。

4.4-7 对递归式 $T(n) = 4T(\lfloor n/2 \rfloor) + cn$ (c 为常数)，画出递归树，并给出其解的一个渐近紧确界。用代入法进行验证。

4.4-8 对递归式 $T(n) = T(n-a) + T(a) + cn$，利用递归树给出一个渐近紧确解，其中 $a \geq 1$ 和 $c > 0$ 是常数。

4.4-9 对递归式 $T(n) = T(\alpha n) + T((1-\alpha) n) + cn$，利用递归树给出一个渐近紧确解，其中 $0 < \alpha < 1$ 和 $c > 0$ 是常数。

### 练习 4.5

4.5-1 对下列递归式，使用主方法求出渐近紧确界。
    a. $T(n) = 2T(n/4) + 1$
    b. $T(n) = 2T(n/4) + \sqrt{n}$
    c. $T(n) = 2T(n/4) + n$
    d. $T(n) = 2T(n/4) + n^2$

4.5-2 Caesar 教授想设计一个渐近快于 Strassen 算法的矩阵相乘算法。他的算法使用分治方法，将每个矩阵分解为 $n/4 \times n/4$ 的子矩阵，分解和合并步骤共花费 $\Theta(n^2)$ 时间。他需要确定，他的算法需要创建多少个子问题，才能击败 Strassen 算法。如果他的算法创建 a 个子问题，则描述运行时间 T(n) 的递归式为 $T(n) = aT(n/4) + \Theta(n^2)$。Caesar 教授的算法如果要渐近快于 Strassen 算法，a 的最大整数值应是多少？

4.5-3 使用主方法证明：二分查找递归式 $T(n) = T(n/2) + \Theta(1)$ 的解是 $T(n) = \Theta(\lg n)$。（二分查找的描述见练习 2.3-5）。

4.5-4 主方法能应用于递归式 $T(n) = 4T(n/2) + n^2 \lg n$ 吗？请说明为什么可以或者为什么不可以。给出这个递归式的一个渐近上界。

*4.5-5 考虑主定理情况 3 的一部分：对某个常数 $c < 1$，正则条件 $af(n/b) \leq cf(n)$ 是否成立。给出一个例子，其中常数 $a \geq 1$，$b > 1$ 且函数 $f(n)$ 满足主定理情况 3 中除正则条件外的所有条件。

### 练习 4.6

*4.6-1 对 b 是正整数而非任意实数的情况，给出公式 (4.27) 中 $n_j$ 的简单而准确的表达式。

*4.6-2 证明：如果 $f(n) = \Theta(n^{\log_b a} \lg^k n)$，其中 $k \geqslant 0$，那么主递归式的解为 $T(n) = \Theta(n^{\log_b a} \lg^{k+1} n)$。为简单起见，假定 n 是 b 的幂。

*4.6-3 证明：主定理中的情况 3 被过分强调了，从某种意义上来说，对某个常数 c < 1，正则条件 $a f(n/b) \leqslant c f(n)$ 成立本身就意味着存在常数 $\varepsilon > 0 $，使得 $ f(n) = \Omega(n^{\log_b a + \varepsilon})$。

### 思考题

4-1 （递归式例子）对于下列每个递归式，给出 $T(n)$ 的渐近上界和下界。假定 $n \leq 2$ 时 $T(n)$ 是常数。给出尽量紧确的界，并验证其正确性。
    a. $T(n) = 2T(n/2) + n^4$
    b. $T(n) = T(n/10) + n$
    c. $T(n) = 16T(n/4) + n^2$
    d. $T(n) = 7T(n/3) + n^2$
    e. $T(n) = 7T(n/2) + n^2$
    f. $T(n) = 2T(n/4) + \sqrt{n}$
    g. $T(n) = T(n-2) + n^2$

4-2 （参数传递代价）我们有一个贯穿本书的假设——过程调用中的参数传递花费常量时间，即使传递一个 $N$ 个元素的数组也是如此。在大多数系统中，这个假设是成立的，因为传递的是指向数组的指针，而非数组本身。本题讨论三种参数传递策略：

1. 数组通过指针来传递。时间 = $\Theta(1)$。
2. 数组通过元素复制来传递。时间 = $\Theta(N)$，其中 $N$ 是数组的规模。
3. 传递数组时，只复制过程可能访问的子区域。若子数组 $A[p..q]$ 被传递，则时间 = $\Theta(q-p+1)$。

a.考虑在有序数组中查找元素的递归二分查找算法 (参见练习 2.3-5)。分别给出上述三种参数传递策略下，二分查找最坏情况下运行时间的递归式，并给出递归式解的好的上界。

令 $N$ 为原问题的规模，$n$ 为子问题的规模。

b.对 2.3.1 节的 MERGE-SORT 算法重做 (c)。

4-3 （更多的递归式例子）对于下列每个递归式，给出 $T(n)$ 的渐近上界和下界。假定对足够小的 $n$，$T(n)$ 是常数。给出尽量紧确的界，并验证其正确性。
    a. $T(n) = 4T(n/2) + n \lg n$
    b. $T(n) = 3T(n/3) + n/\lg n$
    c. $T(n) = 4T(n/2) + n^2 \sqrt{n}$
    d. $T(n) = 2T(n/2-2) + n/2$
    e. $T(n) = 2T(n/2) + n/\lg n$
    f. $T(n) = T(n/2) + T(n/4) + T(n/8) + n$
    g. $T(n) = T(n-1) + 1/n$
    h. $T(n) = T(n-1) + \lg n$
    i. $T(n) = T(n-2) + 1/\lg n$
    j. $T(n) = \sqrt{n}T(\sqrt{n}) + n$

4-4 （斐波那契数）本题讨论递归式 (3.22) 定义的斐波那契数的性质。我们将使用生成函数技术来求解斐波那契递归式。生成函数 (又称为形式幂级数) $\mathcal{F}(z)$ 定义为
$$
\mathcal{F}(z) = \sum_{i = 0}^{\infty} F_i z^i = 0 + z + z^2 + 2z^3 + 3z^4 + 5z^5 + 8z^6 + 13z^7 + 21z^8 + \cdots
$$
其中 $F_i$ 为第 $i$ 个斐波那契数。
a. 证明：$\mathcal{F}(z) = z + z\mathcal{F}(z) + z^2\mathcal{F}(z)$。
b. 证明：
$$
\mathcal{F}(z) = \frac{z}{1 - z - z^2} = \frac{z}{(1 - \phi z)(1 - \hat{\phi} z)} = \frac{1}{\sqrt{5}}\left(\frac{1}{1 - \phi z} - \frac{1}{1 - \hat{\phi} z}\right)
$$
其中
$$
\phi = \frac{1 + \sqrt{5}}{2} = 1.618 03 \cdots
$$
$$
\hat{\phi} = \frac{1 - \sqrt{5}}{2} = -0.618 03 \cdots
$$
c. 证明：
$$
\mathcal{F}(z) = \sum_{i = 0}^{\infty} \frac{1}{\sqrt{5}} (\phi^i - \hat{\phi}^i) z^i
$$

d. 利用 (c) 的结果证明：对 $i \geq 0$，$F_i = \phi^i / \sqrt{5}$，结果舍入到最接近的整数。（提示：观察到 $|\hat{\phi}| < 1$。）

4-5 （芯片检测）Diogenes 教授有 $n$ 片可能完全一样的集成电路芯片，原理上可以用来相互检测。教授的测试夹具同时只能容纳两块芯片。当夹具装载上时，每块芯片都检测另一块，并报告它是好是坏。一块好的芯片总能准确报告另一块芯片的好坏，但教授不能信任坏芯片报告的结果。因此，4 种可能的测试结果如下表：

| 芯片 A 的结果 | 芯片 B 的结果 |           结论           |
| :-----------: | :-----------: | :----------------------: |
|   B 是好的    |   A 是好的    | 两片都是好的，或都是坏的 |
|   B 是好的    |   A 是坏的    |      至少一块是坏的      |
|   B 是坏的    |   A 是好的    |      至少一块是坏的      |
|   B 是坏的    |   A 是坏的    |      至少一块是坏的      |

a. 证明：如果超过 $n/2$ 块芯片是坏的，使用任何基于这种逐对检测操作的策略，教授都不能确定哪些芯片是好的。假定坏芯片可以合谋欺骗教授。
	b. 考虑从 $n$ 块芯片中寻找一块好芯片的问题，假定超过 $n/2$ 块芯片是好的。证明：进行 $n/2$ 次逐对检测足以将问题规模减半。
	c. 假定超过 $n/2$ 块芯片是好的，证明：可以用 $\Theta(n)$ 次逐对检测找到好的芯片。给出描述检测次数的递归，并求解它。

4-6 (Monge 序列)对一个 $m \times n$ 的实数阵列 $A$，若对所有满足 $1 \leq i < k \leq m$ 和 $1 \leq j < l \leq n$ 的 $i, j, k$ 和 $l$ 有
$$
A [i, j] + A [k, l] \leq A [i, l] + A [k, j]
$$
则称 $A$ 是 Monge 阵列 (Monge array)。换句话说，无论何时选定 Monge 阵列的两行和两列，对于交叉点上的 4 个元素，左上和右下两个元素之和总是小于等于左下和右上元素之和。例如，下面就是一个 Monge 阵列：
$$
\begin{bmatrix}
10 & 17 & 13 & 28 & 23 \\
17 & 22 & 16 & 29 & 23 \\
24 & 28 & 22 & 34 & 24 \\
11 & 13 & 6 & 17 & 7 \\
45 & 44 & 32 & 37 & 23 \\
36 & 33 & 19 & 21 & 6 \\
75 & 66 & 51 & 53 & 34 \\
\end{bmatrix}
$$
a. 证明：一个数组是 Monge 阵列当且仅当对所有 $i=1, 2, \cdots, m-1$ 和 $j=1, 2, \cdots, n-1$，有
$$
A [i, j] + A [i+1, j+1] \leq A [i, j+1] + A [i+1, j]
$$
（提示：对于“当”的部分，对所有行和列使用归纳法。）

b. 下面数组不是 Monge 阵列。改变一个元素使其变成 Monge 阵列。（提示：利用 (a) 的结果。）
$$
\begin{bmatrix}
37 & 23 & 22 & 32 \\
21 & 6 & 7 & 10 \\
53 & 34 & 30 & 31 \\
32 & 13 & 9 & 6 \\
43 & 21 & 15 & 8 \\
\end{bmatrix}
$$
c. 令 $f(i)$ 表示第 $i$ 行的最左最小元素的列下标。证明：对任意 $m \times n$ 的 Monge 阵列，$f(1) \leq f(2) \leq \cdots \leq f(m)$。

d. 下面是一个计算 $m \times n$ 的 Monge 阵列 $A$ 每一行最左最小元素的分治算法的描述：
   提取 $A$ 的偶数行构造子矩阵 $A'$。递归地确定 $A'$ 每行的最左最小元素。
   然后计算 $A$ 的奇数行的最左最小元素。
   解释如何在 $O(m+n)$ 时间内计算 $A$ 的奇数行的最左最小元素（在偶数行的最左最小元素已知的情况下）。
e. 给出 (d) 中描述的算法的运行时间的递归式。证明其解为 $O(m+n \log m)$。

## 第五章 概率分析和随机算法

### 练习 5.1



5.1-1 证明：假设在过程 HIRE-ASSISTANT 的第 4 行中，我们总能决定哪一个应聘者最佳，则意味着我们知道应聘者排名的全部次序。

5.1-2 请描述 RANDOM(a, b) 过程的一种实现，它只调用 RANDOM(0, 1)。作为 a 和 b 的函数，你的过程的期望运行时间是多少？

5.1-3 假设你希望以 1/2 的概率输出 0 与 1。你可以自由使用一个输出 0 或 1 的过程 BIASED-RANDOM。它以某概率 p 输出 1，概率 1-p 输出 0，其中 0 < p < 1，但是 p 的值未知。请给出一个利用 BIASED-RANDOM 作为子程序的算法，返回一个无偏的结果，能以概率 1/2 返回 0，以概率 1/2 返回 1。作为 p 的函数，你的算法的期望运行时间是多少？



### 练习 5.2

5.2-1 在 HIRE-ASSISTANT 中，假设应聘者以随机顺序出现，你正好雇用一次的概率是多少？正好雇用 n 次的概率是多少？

5.2-2 在 HIRE-ASSISTANT 中，假设应聘者以随机顺序出现，你正好雇用两次的概率是多少？

5.2-3 利用指示器随机变量来计算掷 n 个骰子之和的期望值。

5.2-4 利用指示器随机变量来解如下的帽子核对问题 (hat-check problem)：n 位顾客，他们每个人给餐厅核对帽子的服务生一顶帽子。服务生以随机顺序将帽子归还给顾客。请问拿到自己帽子的客户的期望数是多少？

5.2-5 设 $A[1..n]$ 是由 n 个不同数构成的数列。如果 $i < j$ 且 $A[i] > A[j]$，则称 (i, j) 对为 A 的一个逆序对 (inversion)。(参看思考题 2-4 中更多关于逆序对的例子。) 假设 A 的元素构成 $\langle 1, 2, \cdots, n \rangle$ 上的一个均匀随机排列。请用指示器随机变量来计算其中逆序对的数目期望。

### 练习 5.3

5.3-1 Marceau 教授不同意引理 5.5 证明中使用的循环不变式。他对第 1 次迭代之前循环不变式是否为真提出质疑。他的理由是，我们可以很容易宣称一个空数组不包含 0 排列。因此，一个空的子数组包含一个 0 排列的概率应是 0，从而第 1 次迭代之前循环不变式无效。请重写过程 RANDOMIZE-IN-PLACE，使得相关循环不变式适用于第 1 次迭代之前的非空子数组，并为你的过程修改引理 5.5 的证明。

5.3-2 Kelp 教授决定写一个过程来随机产生除恒等排列 (identity permutation) 外的任意排列。他提出了如下过程：

```c
PERMUTE-WITHOUT-IDENTITY(A)
    n = A.length
    for i = 1 to n - 1
        swap A[i] with A[RANDOM(i + 1, n)]
```

这段代码实现了 Kelp 教授的意图吗？

5.3-3 假设我们不是将元素 $A[i]$ 与子数组 $A[i...n]$ 中的一个随机元素交换，而是将它与数组任何位置上的随机元素交换：

```c
PERMUTE-WITH-ALL(A)
    n = A.length
    for i = 1 to n
        swap A[i] with A[RANDOM(1, n)]
```

这段代码会产生一个均匀随机排列吗？为什么会或为什么不会？

5.3-4 Armstrong 教授建议用下面的过程来产生一个均匀随机排列：

```c
PERMUTE-BY-CYCLIC(A)
    n = A.length
    let B[1..n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B
```

请说明每个元素 A [i] 出现在 B 中任何特定位置的概率是 1/n。然后通过说明排列结果不是均匀随机排列，表明 Armstrong 教授错了。

5.3-5 证明：在过程 PERMUTE-BY-SORTING 的数组 P 中，所有元素都唯一的概率至少是 1−1/n

5.3-6 请解释如何实现算法 PERMUTE-BY-SORTING，以处理两个或更多优先级相同的情形。也就是说，即使有两个或更多优先级相同，你的算法也应该产生一个均匀随机排列。

5.3-7 假设我们希望创建集合 {1,2,3, ⋯, n}的一个随机样本，即一个具有 m 个元素的集合 S，其中 0≤m≤n，使得每个 m 集合能够等可能地创建。一种方法是对 i = 1,2, ⋯, n 设 A [i] = i，调用 RANDOMIZE-IN-PLACE(A)，然后取最前面的 m 个数组元素。这种方法会对 RANDOM 过程调用 n 次。如果 n 比 m 大很多，我们能够创建一个随机样本，只对 RANDOM 调用更少的次数。请说明下面的递归过程返回 {1,2,3, ⋯, n}的一个随机 m 子集 S，其中每个 m 子集是等可能的，然而只对 RANDOM 调用 m 次。

```c
RANDOM-SAMPLE(m, n)
	if m == 0
        return ∅
    else S = RANDOM-SAMPLE(m - 1, n - 1)
        i = RANDOM(1, n)
        if i ∈ S
            S = S ∪ {n}
        else S = S ∪ {i}
        return S
```

### 练习 5.4

5.4-1 一个屋子里必须要有多少人，才能让某人和你生日相同的概率至少为 $1/2$？必须要有多少人，才能让至少两个人生日为 7 月 4 日的概率大于 $1/2$？

5.4-2 假设我们将球投入到 $b$ 个箱子里，直到某个箱子中有两个球。每一次投掷都是独立的，并且每个球落入任何箱子的机会均等。请问投球次数期望是多少？

*5.4-3 在生日悖论的分析中，要求各人生日彼此独立是否很重要？或者，是否只要两两成对独立就足够了？证明你的答案。

*5.4-4 一次聚会需要邀请多少人，才能让其中 3 人的生日很可能相同？

*5.4-5 在大小为 $n$ 的集合中，一个 $k$ 字符串构成一个 $k$ 排列的概率是多少？这个问题和生日悖论有什么关系？

*5.4-6 假设将 $n$ 个球投入 $n$ 个箱子里，其中每次投球独立，并且每个球等可能落入任何箱子。空箱子的数目期望是多少？正好有一个球的箱子的数目期望是多少？

*5.4-7 为使特征序列长度的下界变得更精确，请说明在 $n$ 次硬币的公平抛掷中，不出现比 $\lg n - 2 \lg \lg n$ 更长的连续正面特征序列的概率小于 $1/n$。

### 思考题

5-1 (概率计数) 利用一个 $b$ 位的计数器，我们一般只能计数到 $2^b-1$。而用 R. Morris 的概率计数法，我们可以计数到一个大得多的值，代价是精度有所损失。

对 $i=0,1,\cdots, 2^b-1$，令计数器值 $i$ 表示 $n_i$ 的计数，其中 $n_i$ 构成了一个非负的递增序列。假设计数器初值为 0，表示计数 $n_0=0$。INCREMENT 运算单元工作在一个计数器上，它以概率的方式包含值 $i$。如果 $i=2^b-1$，则该运算单元报告溢出错误；否则，INCREMENT 运算单元以概率 $1/(n_{i+1}-n_i)$ 把计数器增加 1，以概率 $1-1/(n_{i+1}-n_i)$ 保持计数器不变。

对所有的 $i \geqslant 0$，若选择 $n_i=i$，此计数器就是一个普通的计数器。若选择 $n_i=2^{i-1}(i>0)$，或者 $n_i=F_i$ (第 $i$ 个斐波那契数，参见 3.2 节)，则会出现更多有趣的情形。

对于这个问题，假设 $n_{2^b-1}$ 已足够大，发生一个溢出错误的概率可以忽略。

a. 请说明在执行 $n$ 次 INCREMENT 操作后，计数器所表示的数期望值正好是 $n$。

b. 分析计数器表示的计数的方差依赖于 $n_i$ 序列。我们来看一个简单情形：对所有 $i \geqslant 0$，$n_i=100i$。在执行了 $n$ 次 INCREMENT 操作后，请估计计数器所表示数的方差。

5-2 (查找一个无序数组） 本题将分析三个算法，它们在一个包含 $n$ 个元素的无序数组 $A$ 中查 找一个值 $x$。

考虑如下的随机策略：随机挑选 A 中的一个下标 $i$。如果 $A[i]=x$，则终止；否则，继续挑选 A 中一个新的随机下标。重复随机挑选下标，直到找到一个下标 $j$，使 $A[j]=x$，或者直到我们已检查过 A 中的每一个元素。注意，我们每次都是从全部下标的集合中挑选，于是可能会不止一次地检查某个元素。

a. 请写出过程 RANDOM-SEARCH 的伪代码来实现上述策略。确保当 A 中所有下标都被挑选过时，你的算法应停止。

b. 假定恰好有一个下标 $i$ 使得 $A[i]=x$。在我们找到 $x$ 和 RANDOM-SEARCH 结束之前，必须挑选 A 下标的数目期望是多少？

c. 假设有 $k \geqslant 1$ 个下标 $i$ 使得 $A[i]=x$，推广你对 (b) 部分的解答。在找到 $x$ 或 RANDOM-SEARCH 结束之前，必须挑选 A 的下标的数目期望是多少？你的答案应该是 $n$ 和 $k$ 的函数。

d. 假设没有下标 $i$ 使得 $A[i]=x$。在检查完 A 的所有元素或 RANDOM-SEARCH 结束之前，我们必须挑选 A 的下标的数目期望是多少？

现在考虑一个确定性的线性查找算法，我们称之为 DETERMINISTIC-SEARCH。具体地说，这个算法在 A 中顺序查找 $x$，考虑 $A[1]$, $A[2]$, $A[3]$, $\cdots$, $A[n]$，直到找到 $A[i]=x$，或者到达数组的末尾。假设输入数组的所有排列都是等可能的。

e. 假设恰好有一个下标 $i$ 使得 $A[i]=x$。DETERMINISTIC-SEARCH 平均情形的运行时间是多少？DETERMINISTIC-SEARCH 最坏情形的运行时间又是多少？

f. 假设有 $k \geqslant 1$ 个下标 $i$ 使得 $A[i]=x$，推广你对 (e) 部分的解答。DETERMINISTIC-SEARCH 平均情形的运行时间是多少？DETERMINISTIC-SEARCH 最坏情形的运行时间又是多少？你的答案应是 $n$ 与 $k$ 的函数。

g. 假设没有下标 $i$ 使得 $A[i]=x$。DETERMINISTIC-SEARCH 平均情形的运行时间是多少？DETERMINISTIC-SEARCH 最坏情形的运行时间又是多少？

最后，考虑一个随机算法 SCRAMBLE-SEARCH，它先将输入数组随机变换排列，然后在排列变换后的数组上，运行上面的确定性线性查找算法。

h. 设 $k$ 是满足 $A[i]=x$ 的下标的数目，请给出在 $k=0$ 和 $k=1$ 情况下，算法 SCRAMBLE-SEARCH 最坏情形的运行时间和运行时间期望。推广你的解答以处理 $k \geqslant 1$ 的情况。

i. 你将会使用 3 种查找算法中的哪一个？解释你的答案。



















































