# 第四部分 高级设计和分析技术

## 第十五章 动态规划

### 练习15.1

15.1-1 由公式(15.3)和初始条件 $T(0) = 1$，证明公式(15.4)成立。

15.1-2 举反例证明下面的“贪心”策略不能保证总是得到最优切割方案。定义长度为 $i$ 的钢条的密度为 $p_i/i$，即每英寸的价值。贪心策略将长度为 $n$ 的钢条切割下长度为 $i (1 \leqslant i \leqslant n)$ 的一段，其密度最高。接下来继续使用相同的策略切割长度为 $n-i$ 的剩余部分。

15.1-3 我们对钢条切割问题进行一点修改，除了切割下的钢条段具有不同价格 $p_i$ 外，每次切割还要付出固定的成本 $c$。这样，切割方案的收益就等于钢条段的价格之和减去切割的成本。设计一个动态规划算法解决修改后的钢条切割问题。

15.1-4 修改 MEMOIZED-CUT-ROD，使之不仅返回最优收益值，还返回切割方案。

15.1-5 斐波那契数列可以用递归式(3.22)定义。设计一个 $O(n)$ 时间的动态规划算法计算第 $n$ 个斐波那契数。画出子问题图。图中有多少顶点和边？

### 练习15.2

15.2-1 对矩阵规模序列 $\langle 5, 10, 3, 12, 5, 50, 6 \rangle$，求矩阵链最优括号化方案。

15.2-2 设计递归算法 MATRIX-CHAIN-MULTIPLY($A$, $s$, $i$, $j$)，实现矩阵链最优代价乘法计算的真正计算过程，其输入参数为矩阵序列 $\left(A_1, A_2, \cdots, A_n\right)$，MATRIX-CHAIN-ORDER 得到的表 $s$，以及下标 $i$ 和 $j$。（初始调用应为 MATRIX-CHAIN-MULTIPLY($A$, $s$, 1, $n$)。）

15.2-3 用代入法证明递归公式 (15.6) 的结果为 $\Omega(2^n)$。

15.2-4 对输入链长度为 $n$ 的矩阵链乘法问题，描述其子问题图：它包含多少个顶点？包含多少条边？这些边分别连接哪些顶点？

15.2-5 令 $R(i, j)$ 表示在一次调用 MATRIX-CHAIN-ORDER 过程中，计算其他表项时访问表项 $m[i, j]$ 的次数。证明：
$$
\sum_{i=1}^{n}\sum_{j=i}^{n} R(i, j) = \frac{n^3 - n}{3}
$$
（提示：证明中可用到公式 (A.3)。）

15.2-6 证明：对 $n$ 个元素的表达式进行完全括号化，恰好需要 $n-1$ 对括号。

### 练习15.3

15.3-1 对于矩阵链乘法问题，下面两种确定最优代价的方法哪种更高效？第一种方法是穷举所有可能的括号化方案，对每种方案计算乘法运算次数，第二种方法是运行 RECURSIVE-MATRIX-CHAIN。证明你的结论。

15.3-2 对一个 16 个元素的数组，画出 2.3.1 节中 MERGE-SORT 过程运行的递归调用树。解释备忘技术为什么对 MERGE-SORT 这种分治算法无效。

15.3-3 考虑矩阵链乘法问题的一个变形：目标改为最大化矩阵序列括号化方案的标量乘法运算次数，而非最小化。此问题具有最优子结构性质吗？

15.3-4 如前所述，使用动态规划方法，我们首先求解子问题，然后选择哪些子问题用来构造原问题的最优解。Capulet 教授认为，我们不必为了求原问题的最优解而总是求解出所有子问题。她建议，在求矩阵链乘法问题的最优解时，我们总是可以在求解子问题之前选定 $A_i A_{i+1} \cdots A_j$ 的划分位置 $A_k$（选定的 $k$ 使得 $p_{i-1} p_k p_j$ 最小）。请找出一个反例，证明这个贪心方法可能生成次优解。

15.3-5 对 15.1 节的钢条切割问题加入限制条件：假定对于每种钢条长度 $i (i=1,2,\cdots,n-1)$，最多允许切割出 $l_i$ 段长度为 $i$ 的钢条。证明：15.1 节所描述的最优子结构性质不再成立。

15.3-6 假定你希望兑换外汇，你意识到与其直接兑换，不如进行多种外币的一系列兑换，最后兑换到你想要的那种外币，可能会获得更大收益。假定你可以交易 $n$ 种不同的货币，编号为 1, 2, …, $n$，兑换从 1 号货币开始，最终兑换为 $n$ 号货币。对每两种货币 $i$ 和 $j$，给定汇率 $r_{ij}$，意味着你如果有 $d$ 个单位的货币 $i$，可以兑换 $d r_{ij}$ 个单位的货币 $j$。进行一系列的交易需要支付一定的佣金，金额取决于交易的次数。令 $c_k$ 表示 $k$ 次交易需要支付的佣金。证明：如果对所有 $k=1,2,\cdots, n$，$c_k=0$，那么寻找最优兑换序列的问题具有最优子结构性质。然后请证明：如果佣金 $c_k$ 为任意值，那么问题不一定具有最优子结构性质。

### 练习15.4

15.4-1 求 $\langle 1, 0, 0, 1, 0, 1, 0, 1 \rangle$ 和 $\langle 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0 \rangle$ 的一个 LCS。

15.4-2 设计伪代码，利用完整的表 $c$ 及原始序列 $X = \langle x_1, x_2, \cdots, x_m \rangle$ 和 $Y = \langle y_1, y_2, \cdots, y_n \rangle$ 来重构 LCS，要求运行时间为 $O(m+n)$，不能使用表 $b$。

15.4-3 设计 LCS-LENGTH 的带备忘的版本，运行时间为 $O(mn)$。

15.4-4 说明如何只使用表 $c$ 中 $2 \times \min(m, n)$ 个表项及 $O(1)$ 的额外空间来计算 LCS 的长度。然后说明如何只用 $\min(m, n)$ 个表项及 $O(1)$ 的额外空间完成相同的工作。

15.4-5 设计一个 $O(n^2)$ 时间的算法，求一个 $n$ 个数的序列的最长单调递增子序列。

*15.4-6 设计一个 $O(n \log n)$ 时间的算法，求一个 $n$ 个数的序列的最长单调递增子序列。（提示：注意到，一个长度为 $i$ 的候选子序列的尾元素至少不比一个长度为 $i-1$ 候选子序列的尾元素小。因此，可以在输入序列中将候选子序列链接起来。）

### 练习15.5

15.5-1 设计伪代码 CONSTRUCT-OPTIMAL-BST($root$)，输入为表 $root$，输出是最优二叉搜索树的结构。例如，对图 15-10 中的 $root$ 表，应输出
- $k_2$ 为根
- $k_1$ 为 $k_2$ 的左孩子
- $d_0$ 为 $k_1$ 的左孩子
- $d_1$ 为 $k_1$ 的右孩子
- $k_5$ 为 $k_2$ 的右孩子
- $k_4$ 为 $k_3$ 的左孩子
- $k_3$ 为 $k_4$ 的左孩子
- $d_2$ 为 $k_3$ 的左孩子
- $d_3$ 为 $k_3$ 的右孩子
- $d_4$ 为 $k_4$ 的右孩子
- $d_5$ 为 $k_5$ 的右孩子

与图 15-9(b) 中的最优二叉搜索树对应。

15.5-2 若 7 个关键字的概率如下所示，求其最优二叉搜索树的结构和代价。

| $i$   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $p_i$ |      | 0.04 | 0.06 | 0.08 | 0.02 | 0.10 | 0.12 | 0.14 |
| $q_i$ | 0.06 | 0.06 | 0.06 | 0.06 | 0.05 | 0.05 | 0.05 | 0.05 |

15.5-3 假设 OPTIMAL-BST 不维护表 $u[i, j]$，而是在第 9 行利用公式 (15.12) 直接计算 $w(i, j)$，然后在第 11 行使用此值。如此改动会对渐近时间复杂性有何影响？

*15.5-4 Knuth[212] 已经证明，对所有 $1 \leqslant i < j \leqslant n$，存在最优二叉搜索树，其根满足 $root[i, j-1] \leqslant root[i, j] \leqslant root[i+1, j]$。利用这一特性修改算法 OPTIMAL-BST，使得运行时间减少为 $\Theta(n^2)$。

### 思考题

15-1 （有向无环图中的最长简单路径）给定一个有向无环图 $G = (V, E)$，边权重为实数，给定图中两个顶点 $s$ 和 $t$。设计动态规划算法，求从 $s$ 到 $t$ 的最长加权简单路径。子问题图是怎样的？算法的效率如何？

15-2 （最长回文子序列）回文 (palindrome) 是正序与逆序相同的非空字符串。例如，所有长度为 1 的字符串、civic、racecar、aibohphobia (害怕回文之意) 都是回文。
设计高效算法，求给定输入字符串的最长回文子序列。例如，给定输入 character，算法应该返回 carac。算法的运行时间是怎样的？

15-3 （双调欧几里得旅行商问题）在欧几里得旅行商问题中，给定平面上 $n$ 个点作为输入，希望求出连接所有 $n$ 个点的最短巡游路线。图 15-11(a) 给出了一个 7 点问题的解。此问题是 NP 难问题，因此大家相信它并不存在多项式时间的求解算法 (参见第 34 章)。
J. L. Bentley 建议将问题简化，限制巡游路线为双调巡游 (bitonic tours)，即从最左边的点开始，严格向右前进，直至最右边的点，然后调头严格向左前进，直至回到起始点。图 15-11(b) 给出了相同 7 个点的最短双调巡游路线。问题简化之后，存在一个多项式时间的算法。

![image-20250117231122729](F:\software\Typora\images\image-20250117231122729.png)

设计一个 $O(n^2)$ 时间的最优双调巡游路线算法。你可以认为任何两个点的 $x$ 坐标均不同，且所有实数运算都花费单位时间。（提示：由左至右扫描，对巡游路线的两个部分分别维护可能的最优解。）

15-4 （整齐打印）考虑整齐打印问题，即在打印机上用等宽字符打印一段文本。输入文本为 $n$ 个单词的序列，单词长度分别为 $l_1, l_2, \cdots, l_r$ 个字符。我们希望将此段文本整齐打印在若干行上，每行最多 $M$ 个字符。“整齐”的标准是这样的。如果某行包含第 $i$ 到第 $j (i \leq j)$ 个单词，且单词间隔为一个空格，则行尾的额外空格字符数量为 $M - j + 5 - \sum_{i}^{j} l_i$，此值必须为非负的，否则一行内无法容纳这些单词。我们希望能最小化所有行的（除最后一行外）额外空格数的立方之和。设计一个动态规划算法，在打印机上整齐打印一段 $n$ 个单词的文本。分析算法的时间和空间复杂性。

15-5 （编辑距离）为了将一个文本串 $x[1 \cdots m]$ 转换为目标串 $y[1 \cdots n]$，我们可以使用多种变换操作。我们的目标是，给定 $x$ 和 $y$，求将 $x$ 转换为 $y$ 的一个变换操作序列。我们使用一个数组 $z$ 保存中间结果，假定它足够大，可存下中间结果的所有字符。初始时，$z$ 是空的，结束时，应有 $z[j] = y[1 \cdots n]$，$j = 1, 2, \cdots, n$。我们维护两个下标 $i$ 和 $j$，分别指向 $x$ 中位置和 $z$ 中位置，变换操作允许改变 $z$ 的内容和这两个下标。初始时，$i = j = 1$。在转换过程中处理 $x$ 的所有字符，这意味着在变换操作结束时，应有 $i = m + 1$。
我们可以使用如下 6 种变换操作：
- 复制 (copy) — 从 $x$ 复制一个字符到 $z$，即进行赋值 $z[j] = x[i]$，并将两个下标 $i$ 和 $j$ 都增 1。此操作处理了 $x[i]$。
- 替换 (replace) — 将 $x$ 中一个字符替换为另一个字符 $c$，$z[j] = c$，并将两个下标 $i$ 和 $j$ 都增 1。此操作处理了 $x[i]$。
- 删除 (delete) — 删除 $x$ 中一个字符，即将 $i$ 增 1，$j$ 不变。此操作处理了 $x[i]$。
- 插入 (insert) — 将字符 $c$ 插入 $x$ 中，$z[j] = c$，将 $j$ 增 1，$i$ 不变。此操作未处理 $x$ 中字符。
- 旋转 (twiddle, 即交换) — 将 $x$ 中下两个字符复制到 $z$ 中，但交换顺序，$z[j] = x[i+1]$ 且 $z[j+1] = x[i]$，将 $i$ 和 $j$ 都增 2。此操作处理了 $x[i]$ 和 $x[i+1]$。
- 终止 (kill) — 删除 $x$ 中剩余字符，令 $i = m + 1$。此操作处理了 $x$ 中所有尚未处理的字符。如果执行此操作，则转换过程结束。

下面给出了将源字符串 algorithm 转换为目标字符串 altruistic 的一种变换操作序列，下划线指出执行一个变换操作后两个下标的位置：

| 操作     | 初始字符串 | algorithm            | $z$    | $i$  | $j$  |
| -------- | ---------- | -------------------- | ------ | ---- | ---- |
| 插入 i   | algorithm  | altruistic_algorithm | a      | 0    | 1    |
| 复制     | algorithm  | altruistic_algorithm | alt    | 1    | 2    |
| 替换为 t | algorithm  | altruistic_algorithm | altt   | 2    | 3    |
| 删除     | algorithm  | altruistic_algorithm | altt   | 3    | 3    |
| 复制     | algorithm  | altruistic_algorithm | alttr  | 4    | 4    |
| 插入 u   | algorithm  | altruistic_algorithm | alttru | 5    | 5    |

注意，还有其他方法将 algorithm 转换为 altruistic。

每个变换操作都有相应的代价。具体的代价依赖于特定的应用，但我们假定每个操作的代价是一个已知的常量。我们还假定复制和替换的代价小于删除和插入的组合代价，否则复制和替换操作就没有意义了。一个给定的变换操作序列的代价为其中所有变换操作的代价之和。在上例中，将 algorithm 转换为 altruistic 的代价为
$$(3 \cdot \text{cost(复制)}) + \text{cost(替换)} + \text{cost(删除)} + (4 \cdot \text{cost(插入)}) + \text{cost(旋转)} + \text{cost(终止)}$$

a. 给定两个字符串 $x[1.. m]$ 和 $y[1.. n]$ 以及变换操作的代价，$x$ 到 $y$ 编辑距离 (edit distance) 是将 $x$ 转换为 $y$ 的最小代价的变换操作序列的代价值。设计动态规划算法，求 $x[1.. m]$ 到 $y[1.. n]$ 的编辑距离并打印最优变换操作序列。分析算法的时间和空间复杂度。

编辑距离问题是 DNA 序列对齐问题的推广（参考其他文献，如 Setubal 和 Meidanis [310, 3.2 节]）。已有多种方法可以通过对齐两个 DNA 序列来衡量它们的相似度。有一种对齐方法是将空格符插入到两个序列 $x$ 和 $y$ 中，可以插入到任何位置（包括两端），使得结果序列 $x'$ 和 $y'$ 具有相同的长度，但不会在相同的位置出现空格符（即不存在位置 $j$ 使得 $x'[j]$ 和 $y'[j]$ 都是空格符）。然后为每个位置“打分”，位置 $j$ 的分数为：
- +1，如果 $x'[j] = y'[j]$ 且不是空格符。
- -1，如果 $x'[j] \neq y'[j]$ 且都不是空格符。
- -2，$x'[j]$ 或 $y'[j]$ 是空格符。

对齐方案的分数为每个位置的分数之和。例如，给定序列 $x = \text{GATCGGCAT}$ 和 $y = \text{CAATGTGAATC}$，一种对齐方案为

```
G ATCG GCAT 
C AATGTGAATC
-*++*+*+-++*
```

+表示该位置分数为 +1，− 表示分数为 −1，* 表示分数为 −2，因此此方案的总分数为 $6 \cdot 1 - 2 \cdot 1 - 4 \cdot 2 = -4$。

b. 解释如何将最优对齐问题转换为编辑距离问题，使用的操作为变换操作复制、替换、删除、插入、旋转和终止的子集。

15-6 （公司聚会计划）一位公司主席正在向 Stewart 教授咨询公司聚会的计划。公司的内部结构关系是层次化的，即员工按主管—下属关系构成一棵树，根结点为公司主席。人事部按“宴会交际能力”为每个员工打分，分值为实数。为了使所有参加聚会的员工都感到愉快，主席不希望员工及其直接主管同时出席。

公司主席向 Stewart 教授提供公司结构，采用 10.4 节介绍的左孩子右兄弟表示法描述。书中每个结点除了保存指针外，还保存员工的名字和宴会交际评分。设计算法，求宴会交际评分之和最大的宾客名单。分析算法的时间复杂度。

15-7 （译码算法）我们可以通过在有向图 $G = (V, E)$ 上使用动态规划方法来实现语音识别。对每条边 $(u, v) \in E$ 打上一个声音标签 $\sigma(u, v)$，该声音来自于有限声音集 $\Sigma$。这样的标签图就成为一个特定人说限定语言的形式化模型。图中从特定顶点 $v_b \in V$ 开始的每条路径都对应模型产生的一个可能的声音序列。对于一条有向路径，我们定义其标签为路径中边的标签的简单连结。

a. 设计高效算法，对给定的带边标签的图 $G$、特定顶点 $v_b$ 及 $\Sigma$ 上的声音序列 $s = (\sigma_1, \sigma_2, \cdots)$，返回 $G$ 中从 $v_b$ 开始的一条路径，$s$ 为该路径的标签（如果存在这样的路径）。否则，算法应返回 NO-SUCH-PATH。分析算法的时间复杂度（提示：你可能发现第 2 章中的概念可以用于此题）。

b. 扩展 (a) 中的算法，使得返回的路径是从 $v_b$ 开始且标签为 $s$ 的路径中概率最大者。分析算法的时间复杂性。算法的时间复杂性。

15-8 （基于接缝裁剪 (seam carving) 的图像压缩）给定一幅彩色图像，它由一个 $m \times n$ 的像素数组 $A[1.. m, 1.. n]$ 构成，每个像素是一个红绿蓝 (RGB) 亮度的三元组。假定我们希望轻度压缩这幅图像。具体地，我们希望从每一行中删除一个像素，使得图像变窄一个像素。但为了避免影响视觉效果，我们要求相邻两行中删除的像素必须位于同一列或相邻列。也就是说，删除的像素构成从顶端行到底端行的一条“接缝” (seam)，相邻像素均在垂直或对角线方向上相邻。
	a. 证明：可能的缝的数量是 $m$ 的指数函数，假定 $n > 1$。
	b. 假定现在对每个像素 $A[i, j]$ 我们都已计算出一个实型的“破坏度” $d[i, j]$，表示删除像素 $A[i,j]$ 对图像可视效果的破坏程度。直观地，一个像素的破坏度越低，它与相邻像素的相似度越高。再假定一条接缝的破坏度定义为它包含的像素的破坏度之和。设计算法，寻找破坏度最低的接缝。分析算法的时间复杂度。

15-9 （字符串拆分）某种字符串处理语言允许程序员将一个字符串拆分为两段。由于此操作需要复制字符串，因此要花费 $n$ 个时间单位来将一个 $n$ 个字符的字符串拆为两段。假定一个程序员希望将一个字符串拆分为多段，拆分的顺序会影响所花费的总时间。例如，假定这个程序员希望将一个 20 个字符的字符串在第 2 个、第 8 个以及第 10 个字符后进行拆分（字符由左至右，从 1 开始升序编号）。如果她按由左至右的顺序进行拆分，则第一次拆分花费 20 个时间单位，第二次拆分花费 18 个时间单位（在第 8 个字符处拆分 3~20 间的字符串），而第三次拆分花费 12 个时间单位，共花费 50 个时间单位。但如果她按由右至左的顺序进行拆分，第一次拆分花费 20 个时间单位，第二次拆分花费 10 个时间单位，而第三次拆分花费 8个时间单位，共花费 38 个时间单位。还可以按其他顺序，先在第 8 个字符处进行拆分（时间 20），接着在左边一段第 2 个字符处进行拆分（时间 8），最后在右边一段第 10 个字符处进行拆分（时间 12），总时间为 40。
	设计算法，对给定的拆分位置，确定最小代价的拆分顺序。更形式化地，给定一个 $n$ 个字符的字符串 $S$ 和一个保存 $m$ 个拆分点的数组 $L[1..m]$，计算拆分的最小代价，以及最优拆分序列。

15-10 （投资策略规划）你所掌握的算法知识帮助你从 Acme 计算机公司获得了一份令人兴奋的工作，签约奖金 1 万美元。你决定利用这笔钱进行投资，目标是 10 年后获得最大回报。你决定请 Amalgamated 投资公司管理你的投资，该公司的投资回报规则如下。该公司提供 $n$ 种不同的投资，从 1~$n$ 编号。在第 $j$ 年，第 $i$ 种投资的回报率为 $r_{ij}$。换句话说，如果你在第 $j$ 年在第 $i$ 种投资投入 $d$ 美元，那么在第 $j$ 年年底，你会得到 $dr_{ij}$ 美元。回报率是有保证的，即未来 10 年每种投资的回报率均已知。你每年只能做出一次投资决定。在每年年底，你既可以将钱继续投入到上一年选择的投资种类中，也可以转移到其他投资中（转移到已有的投资种类，或者新的投资种类）。如果跨年时你不做投资转移，需要支付 $f_1$ 美元的费用，否则，需要支付 $f_2$ 美元的费用，其中 $f_2 > f_1$。

a. 如上所述，本问题允许你每年将钱投入到多种投资中。证明：存在最优投资策略，每年都将所有钱投入到单一投资中（记住最优投资策略只需最大化 10 年的回报，无需关心任何其他目标，如最小化风险）。

b. 证明：规划最优投资策略问题具有最优子结构性质。

c. 设计最优投资策略规划算法，分析算法时间复杂度。

d. 假定 Amalgamated 投资公司在上述规则上又加入了新的限制条款，在任何时刻你都不能在任何单一投资种类中投入 15 000 美元以上。证明：最大化 10 年回报问题不再具有最优子结构性质。

15-11 （库存规划）Rinky Dink 公司是一家制造溜冰场冰面修整设备的公司。这种设备每个月的需求量都在变化，因此公司希望设计一种策略来规划生产，需求是给定的，即它虽然是波动的，但是可预测的。公司希望设计接下来 $n$ 个月的生产计划。对第 $i$ 个月，公司知道需求 $d_i$，即该月能够销售出去的设备的数量。令 $D = \sum_{i=1}^{n} d_i$ 为后 $n$ 个月的总需求。公司雇用的全职员工，可以提供一个月制造 $m$ 台设备的劳动力。如果公司希望一个月内制造多于 $m$ 台设备，可以雇用额外的兼职劳动力，雇用成本为每制造一台机器付出 $c$ 美元。而且，如果在月末有设备尚未售出，公司还要付出库存成本。保存 $j$ 台设备的成本可描述为一个函数 $h(j)$，$j=1, 2, \cdots, D$ 其中对所有 $1 \leqslant j \leqslant D$，$h(j) \geqslant 0$，对 $1 \leqslant j \leqslant D-1$，$h(j) \leqslant h(j+1)$。

设计库存规划算法，在满足所有需求的前提下最小化成本。算法运行时间应为 $n$ 和 $D$ 的多项式函数。

15-12 （签约棒球自由球员）假设你是一支棒球大联盟球队的总经理。在赛季休季期间，你需要签入一些自由球员。球队老板给你的预算为 $X$ 美元，你可以使用少于 $X$ 美元来签人球员，但如果超支，球队老板就会解雇你。

你正在考虑在 $N$ 个不同位置签人球员，在每个位置上，有 $P$ 个该位置的自由球员供你选择。由于你不希望任何位置过于臃肿，因此每个位置最多签入一名球员（如果在某个特定位置上你没有签入任何球员，则意味着计划继续使用现有球员）。

为了确定一名球员的价值，你决定使用一种称为“VORP”，或“球员替换价值”（value over replacement player）的统计评价指标。球员的 VORP 值越高，其价值越高。但 VORP 值高的球员的签约费用并不一定比 VORP 值低的球员高，因为还有球员价值之外的因素影响签约费用。

对于每个可选择的自由球员，你知道他的三方面信息：
- 他打哪个位置。
- 他的签约费用。
- 他的 VORP。

设计一个球员选择算法，使得总签约费用不超过 $X$ 美元，而球员的总 VORP 最大。你可以假定每位球员的签约费用是 10 万美元的整数倍。算法应输出签约球员的总 VORP 值、总签约费用，以及球员名单。分析算法的时间和空间复杂度。







## 第十六章 贪心算法

### 练习16.1

16.1-1 根据递归式(16.2)为活动选择问题设计一个动态规划算法。算法应该按前文定义计算最大兼容活动集的大小 $c[i, j]$ 并生成最大集本身。假定输入的活动已按公式(16.1)排好序。比较你的算法和 GREEDY-ACTIVITY-SELECTOR 的运行时间。

16.1-2 假定我们不再一直选择最早结束的活动，而是选择最晚开始的活动，前提仍然是与之前选出的所有活动均兼容。描述如何利用这一方法设计贪心算法，并证明算法会产生最优解。

16.1-3 对于活动选择问题，并不是所有贪心方法都能得到最大兼容活动子集。请举例说明，在剩余兼容活动中选择持续时间最短者不能得到最大集。类似地，说明在剩余兼容活动中选择与其他剩余活动重叠最少者，以及选择最早开始者均不能得到最优解。

16.1-4 假定有一组活动，我们需要将它们安排到一些教室，任意活动都可以在任意教室进行。我们希望使用最少的教室完成所有活动。设计一个高效的贪心算法求每个活动应该在哪个教室进行。

（这个问题称为区间图着色问题 (interval-graph color problem)。我们可以构造一个区间图，顶点表示给定的活动，边连接不兼容的活动。要求用最少的颜色对顶点进行着色，使得所有相邻顶点颜色均不相同——这与使用最少的教室完成所有活动的问题是对应的。）

16.1-5 考虑活动选择问题的一个变形：每个活动 $a_i$ 除了开始和结束时间外，还有一个值 $v_i$。目标不再是求规模最大的兼容活动子集，而是求值之和最大的兼容活动子集。也就是说，选择一个兼容活动子集 $A$，使得 $\sum_{a_k \in A} v_k$ 最大。设计一个多项式时间的算法求解此问题。

### 练习16.2

16.2-1 证明：分数背包问题具有贪心选择性质。

16.2-2 设计动态规划算法求解 0-1 背包问题，要求运行时间为 $O(nW)$，$n$ 为商品数量，$W$ 是小偷能放进背包的最大商品总重量。

16.2-3 假定在 0-1 背包问题中，商品的重量递增序与价值递减序完全一样。设计一个高效算法求此背包问题的变形的最优解，证明你的算法是正确的。

16.2-4 Gekko 教授一直梦想用直排轮滑的方式横穿北达科他州。他计划沿 U.S. 2 号高速公路横穿，这条高速公路从明尼苏达州东部边境的大福克斯市到靠近蒙大拿州西部边境的威利斯顿市。教授计划带两公升水，在喝光水之前能滑行 $m$ 英里（由于北达科他州地势相对平坦，教授无需担心在上坡路段喝水速度比平地或下坡路段快）。教授从大福克斯市出发时带整整两公升水。他携带的北达科他州官方地图显示了 U.S. 2 号公路上所有可以补充水的地点，以及这些地点间的距离。

教授的目标是最小化横穿途中补充水的次数。设计一个高效的方法，以帮助教授确定应该在哪些地点补充水。证明你的策略会生成最优解，分析其运行时间。

16.2-5 设计一个高效算法，对实数线上给定的一个点集 $\{x_1, x_2, \cdots, x_n\}$，求一个单位长度闭区间的集合，包含所有给定的点，并要求此集合最小。证明你的算法是正确的。

*16.2-6 设计算法，在 $O(n)$ 时间内求解分数背包问题。

16.2-7 给定两个集合 $A$ 和 $B$，各包含 $n$ 个正整数。你可以按需要任意重排每个集合。重排后，令 $a_i$ 为集合 $A$ 的第 $i$ 个元素，$b_i$ 为集合 $B$ 的第 $i$ 个元素。于是你得到回报 $\prod_{i=1}^{n} a_i b_i$。设计算法最大化你的回报。证明你的算法是正确的，并分析运行时间。

### 练习16.3

16.3-1 请解释，在引理 16.2 的证明中，为什么若 $x.freq = b.freq$，则有 $a.freq = b.freq$ 且 $x.freq = y.freq$。

16.3-2 证明：一棵不满的二叉树不可能对应一个最优前缀码。

16.3-3 如下所示，8 个字符对应的出现频率是斐波那契数列的前 8 个数，此频率集合的赫夫曼编码是怎样的？
- $a: 1$ $b: 1$ $c: 2$ $d: 3$ $e: 5$ $f: 8$ $g: 13$ $h: 21$

​	你能推广你的结论，求频率集为前 $n$ 个斐波那契数的最优前缀码吗？

16.3-4 证明：编码树的总代价还可以表示为所有内部结点的两个孩子结点的联合频率之和。

16.3-5 证明：如果我们将字母表中字符按频率单调递减排序，那么存在一个最优编码，其码字长度是单调递增的。

16.3-6 假定我们有字母表 $C = \{0, 1, \cdots, n-1\}$ 上的一个最优前缀码，我们希望用最少的二进制位传输此编码。说明如何仅用 $2n-1 + n \lceil\log n$ 位表示 $C$ 上的任意最优前缀码。（提示：通过对树的遍历，用 $2n-1$ 位说明编码树的结构。）

16.3-7 推广赫夫曼算法，使之能生成三进制的码字（即码字由符号 0、1、2 组成），并证明你的算法能生成最优三进制码。

16.3-8 假定一个数据文件由 8 位字符组成，其中所有 256 个字符出现的频率大致相同：最高的频率也低于最低频率的 2 倍。证明：在此情况下，赫夫曼编码并不比 8 位固定长度编码更高效。

16.3-9 证明：对于一个由随机生成的 8 位字符组成的文件，没有任何压缩方法可以望将其压缩，哪怕只是压缩一位。（提示：比较可能的文件数量和可能的编码文件数量。）

### 练习16.4

16.4-1 证明：若 $S$ 是任意一个有限集，$\mathcal{I}_k$ 是 $S$ 的所有规模不超过 $k$ 的子集的集合 $(k \leq |S|)$，则 $(S, \mathcal{I}_k)$ 是一个拟阵。

*16.4-2 给定某个域（如实数域）上的 $m \times n$ 矩阵 $T$，证明：$(S, \mathcal{I})$ 是一个拟阵，其中 $S$ 是 $T$ 的列的集合，且 $A \in \mathcal{I}$ 当且仅当 $A$ 中的列是线性无关的。

*16.4-3 证明：若 $(S, \mathcal{I})$ 是一个拟阵，则 $(S, \mathcal{I}^{\prime})$ 也是一个拟阵，其中
$$\mathcal{I}^{\prime} = \{A^{\prime}: S - A^{\prime} \text{包含某些最大独立子集} A \in \mathcal{I}\}$$，即 $(S, \mathcal{I}^{\prime})$ 的最大独立子集恰好是 $(S, \mathcal{I})$ 的最大独立子集的补集。

*16.4-4 令 $S$ 是一个有限集，$S_1, S_2, \cdots, S_k$ 是 $S$ 的一个划分，这些集合都是非空且不相交的。定义结构 $(S, \mathcal{I})$ 满足条件 $\mathcal{I} = \{A: |A \cap S_i| \leqslant 1, i = 1, 2, \cdots, k\}$。证明：$(S, \mathcal{I})$ 是一个拟阵。也就是说，与划分中所有子集都最多有一个共同元素的集合 $A$ 组成的集合构成了拟阵的独立集。

16.4-5 对于一个所需最优化解为最小权重最大独立子集的加权拟阵问题，如何将其权重函数进行转换，使其变为标准的加权拟阵问题。详细论证你的转换方法是正确的。

### 练习16.5

16.5-1 对图 16-7 给出的调度问题的实例，将每个惩罚值 $w_i$ 替换为 $80 - w_i$，求解修改后的问题。

16.5-2 说明如何利用引理 16.12 的性质 2 在 $O(|A|)$ 时间内确定一个给定任务集合 $A$ 是独立的。

### 思考题

16-1 （找零问题）考虑用最少的硬币找 $\pi$ 美分零钱的问题。假定每种硬币的面额都是整数。
a. 设计贪心算法求解找零问题，假定有 25 美分、10 美分、5 美分和 1 美分 4 种面额的硬币。证明你的算法能找到最优解。
b. 假定硬币面额是 $c$ 的幂，即面额为 $c^2, c^1, \cdots, c^k$ 和 $k$ 为整数，$c \geq 1, k \geq 1$。证明：贪心算法总能得到最优解。
c. 设计一组硬币面额。使得贪心算法不能保证得到最优解。这组硬币面额中应该包含 1 美分，使得对每个零钱值都存在找零方案。
d. 设计一个 $O(n k)$ 时间的找零算法，适用于任何 $k$ 种不同面额的硬币，假定总是包含 1 美分硬币。

16-2 （最小平均完成时间调度问题）假定给定任务集合 $S = \{a_1, a_2, \cdots, a_n\}$，其中任务 $a_i$ 在启动后需要 $p_i$ 个时间单位完成。你有一台计算机来运行这些任务，每个时刻只能运行一个任务。令 $c_i$ 表示任务 $a_i$ 的完成时间，即任务 $a_i$ 被执行完的时间。你的目标是最小化平均完成时间，即最小化 $(1/n) \sum_{i=1}^{n} c_i$。例如，假定有两个任务 $a_1$ 和 $a_2$，$p_1 = 3, p_2 = 5$，如果 $a_1$ 首先运行，然后运行 $a_2$，则 $c_2 = 5, c_1 = 8$，平均完成时间为 $(5 + 8)/2 = 6.5$。如果 $a_2$ 先于 $a_1$ 执行，则 $c_1 = 3, c_2 = 8$，平均完成时间为 $(3 + 8)/2 = 5.5$。

a. 设计算法，求平均完成时间最小的调度方案。任务的执行都是非抢占的，即一旦 $a_i$ 开始运行，它就持续运行 $p_i$ 个时间单位。证明你的算法能最小化平均完成时间，并分析算法的运行时间。

b. 现在假定任务并不是在任意时刻都可以开始执行，每个任务都有一个释放时间 $r_i$，在此时间之后才可以开始。此外假定任务执行是可以抢占的 (preemption)，这样任务可以被挂起，稍后再重新开始。例如，一个任务 $a_i$ 的运行时间为 $p_i = 6$，释放时间为 $r_i = 1$，它可能在时刻 1 开始运行，在时刻 4 被抢占。然后在时刻 10 恢复运行，在时刻 11 再次被抢占，最后在时刻 13 恢复运行，在时刻 15 运行完毕。任务 $a_i$ 共运行了 6 个时间单位，但运行时间被分割成三部分。在此情况下，$a_i$ 的完成时间为 15。设计算法，对此问题求解平均运行时间最小的调度方案。证明你的算法确实能最小化完成时间，分析算法的运行时间。

16-3 （无环子图）

a. 一个无向图 $G = (V, E)$ 的关联矩阵 (incidence matrix) 是一个 $|V| \times |E|$ 的矩阵 $M$，若边 $e$ 关联于顶点 $v$，则 $M_{uv} = 1$，否则 $M_{uv} = 0$。论证 $M$ 的一个列集合在整数模 2 的城上线性无关当且仅当对应的边集无环。

b. 假定我们对一个无向图 $G = (V, E)$ 的每条边都关联一个非负权重 $w(e)$。设计一个高效算法，求权重之和最大的无环边集。

c. 令 $G = (V, E)$ 是任意的有向图，定义 $(E, I)$ 满足 $A \in I$ 当且仅当 $A$ 不包含任何有向环。给出一个有向图 $G$ 的例子，使得关联的系统 $(E, I)$ 不是一个拟阵。指出定义中哪个条件使得系统 $(E, I)$ 不是拟阵。

d. 无自环的有向图 $G = (V, E)$ 的关联矩阵是一个 $|V| \times |E|$ 的矩阵 $M$，若边 $e$ 从顶点 $v$ 发出，则 $M_{uv} = -1$，若边 $e$ 指向顶点 $v$，则 $M_{uv} = 1$，否则 $M_{uv} = 0$，证明：如果 $M$ 的一个列集合线性无关，那么对应的边集不包含有向环。

e. 练习 16.4-2 告诉我们任意矩阵 $M$ 的线性无关的列集合的集合构成一个拟阵。仔细解释 (c) 和 (e) 的结果为什么不矛盾。什么情况下边集无环与关联矩阵中对应列集合线性无关这两个问题间没有完美的对应关系？

16-4 （调度问题变形）对 16.5 节中带截止时间和惩罚的单位时间任务调度问题，考虑如下算法。初始时令 $n$ 个时间槽均为空，时间槽 $i$ 为单位时间长度，结束于时刻 $i$。我们按惩罚值单调递减的顺序处理所有任务。当处理任务 $a_i$ 时，如果存在不晚于 $a_i$ 的截止时间 $d_i$ 的空时间槽，则将 $a_i$ 分配到其中最晚的那个。如果不存在这样的时间槽，将 $a_i$ 分配到最晚的空时间槽。

a. 证明：此算法总能得到最优解。

b. 利用 21.3 节提出的快速不相交集合森林来高效实现此算法。假定输入任务集合已经按惩罚值单调递减的顺序排序。分析实现程序的运行时间。

16-5 （离线缓存）现代计算机使用缓存技术将少量数据保存于快速内存中。虽然程序可能访问大量数据，但通过将主存中少量数据保存在缓存（cache）一容量小但更快的内存中，还是可以大幅度降低访问时间。当一个计算机程序运行时，它对内存进行 $n$ 次内存访问 $(r_1, \cdots, r_n)$，每个请求访问一个特定数据元素。例如，一个程序访问 4 个不同元素 $(a, b, c, d)$，访问请求序列为 $(d, b, d, b, a, c, d, b, a, c, b)$，令 $k$ 为缓存的规模，当缓存已经保存了 $k$ 个元素，而程序访问第 $(k+1)$ 个元素时，系统必须决定，对于此访问及之后的请求，要将哪 $k$ 个元素保存在缓存中。更准确地说，对每个请求，缓存管理算法检查元素 $r_i$ 是否在缓存中。如果已在，就产生一次缓存命中（cache hit）；否则，产生一次缓存未命中（cache miss）。若产生缓存未命中，系统从主存中提取 $r_i$，同时缓存管理算法必须决定是否将 $r_i$ 保留在缓存中。如果缓存决定保留 $r_i$，且缓存中已经保存了 $k$ 个元素，则它必须将某个元素逐出缓存来为 $r_i$ 腾出空间。缓存管理算法逐出数据的目标是在处理整个访问请求序列的过程中缓存未命中的次数最少。

通常，缓存管理是一个在线问题。也就是说，我们在决定将哪些数据保留在缓存中时，并不知道未来的访问请求是什么。但是，我们这里考虑此问题的离线版本，即预先知 道完整的请求序列（包含$n$个访问请求）及缓存规模$k$, 目标仍是最小化缓存未命中次数。 我们可以用一种称为将来最远(furthest-in-future) 的贪心策略求解离线缓存问题，此策略选择逐出缓存的数据的方法是选择在请求序列中下一次访问距离最远的数据。

a. 编写使用将来最远策略的缓存管理器的伪代码。输入是请求序列 $\langle r_1, r_2, \cdots, r_n \rangle$ 和缓存规模 $k$，输出为决策结果序列——处理每个请求时逐出缓存的是哪个数据（如果需要逐出）。分析算法的运行时间。

b. 证明：离线缓存问题具有最优子结构性质。

c. 证明：将来最远策略可以保证最小缓存未命中次数。

## 第十七章 摊还分析

#### 练习17.1

17.1-1 如果栈操作包括 MULTIPUSH 操作，它将 $k$ 个数据项压入栈中，那么栈操作的摊还代价的界还是 $O(1)$ 吗？

17.1-2 证明：如果 $k$ 位计数器的例子中允许 DECREMENT 操作，那么 $n$ 个操作的运行时间可能达到 $\Theta(nk)$。

17.1-3 假定我们对一个数据结构执行一个由 $n$ 个操作组成的操作序列，当 $i$ 严格为 2 的幂时，第 $i$ 个操作的代价为 $i$，否则代价为 1。使用聚合分析确定每个操作的摊还代价。

#### 练习17.2

17.2-1 假定对一个规模永远不会超过 $k$ 的栈执行一个栈操作序列。执行 $k$ 个操作后，我们复制整个栈来进行备份。通过为不同的栈操作赋予适合的摊还代价，证明：$n$ 个栈操作（包括复制栈）的代价为 $O(n)$。

17.2-2 用核算法重做练习 17.1-3。

17.2-3 假定我们不仅对计数器进行增 1 操作，还会进行置 0 操作（即将所有位复位）。设检测或修改一个位的时间为 $\Theta(1)$，说明如何用一个位数组来实现计数器，使得对一个初值为 0 的计数器执行一个由任意 $n$ 个 INCREMENT 和 RESET 操作组成的序列花费时间 $\Theta(n)$。（提示：维护一个指针一直指向最高位的 1。）

#### 练习17.3

17.3-1 假定有势函数 $\Phi$，对所有 $i$ 满足 $\Phi(D_i) \geqslant \Phi(D_0)$，但 $\Phi(D_0) \neq 0$。证明：存在势函数 $\Phi'$，使得 $\Phi'(D_0) = 0$，对所有 $i \geqslant 1$ 满足 $\Phi'(D_i) \geqslant 0$，且使用 $\Phi'$ 的摊还代价与使用 $\Phi$ 的摊还代价相同。

17.3-2 使用势能法重做练习 17.1-3。

17.3-3 考虑一个包含 $n$ 个元素的普通二叉最小堆数据结构，它支持 INSERT 和 EXTRACT-MIN 操作，最坏情况时间均为 $O(\log n)$。给出一个势函数 $\Phi$，使得 INSERT 操作的摊还代价为 $O(\log n)$，而 EXTRACT-MIN 操作的摊还代价为 $O(1)$，证明它是正确的。

17.3-4 执行 $n$ 个 PUSH、POP 和 MULTIPOP 栈操作的总代价是多少？假定初始时栈中包含 $s_0$ 个对象，结束后包含 $s_n$ 个对象。

17.3-5 假定计数器初值不是 0，而是包含 $b$ 个 1 的二进制数。证明：若 $n = \Omega(b)$，则执行 $n$ 个 INCREMENT 操作的代价为 $O(n)$。（不要假定 $b$ 是常量。）

17.3-6 证明：如何用两个普通的栈实现一个队列（练习 10.1-6），使得每个 ENQUEUE 和 DEQUEUE 操作的摊还代价为 $O(1)$。

17.3-7 为动态整数多重集 $S$（允许包含重复值）设计一种数据结构，支持如下两个操作：
- INSERT($S, x$) 将 $x$ 插入 $S$ 中。
- DELETE-LARGER-HALF($S$) 将最大的 $\lceil|S|/2\rceil$ 个元素从 $S$ 中删除。

解释如何实现这种数据结构，使得任意 $m$ 个 INSERT 和 DELETE-LARGER-HALF 操作的序列能在 $O(m)$ 时间内完成。还要实现一个能在 $O(|S|)$ 时间内输出所有元素的操作。

#### 练习17.4

17.4-1 假定我们希望实现一个动态的开地址散列表。为什么我们需要当装载因子达到一个严格小于 1 的值 $\alpha$ 时就认为表满？简要描述如何为动态开地址散列表设计一个插入算法，使得每个插入操作的摊还代价的期望值为 $O(1)$。为什么每个插入操作的实际代价的期望值不必对所有插入操作都是 $O(1)$？

17.4-2 证明：如果动态表的 $\alpha_{i-1} \geqslant 1/2$ 且第 $i$ 个操作是 TABLE-DELETE，那么用势函数公式 (17.6) 定义的操作的摊还代价的上界是一个常数。

17.4-3 假定我们改变表收缩的方式，不是当装载因子小于 $1/4$ 时将表规模减半，而是当装载因子小于 $1/3$ 时将表规模变为原来的 $2/3$​。使用势函数
$$
\Phi(T) = |2 \cdot T.num - T.size|
$$
证明：使用此策略，TABLE-DELETE 操作的摊还代价的上界是一个常数。



#### 思考题

17-1 （位逆序的二进制FFT）第 30 章介绍了一个称为快速逆序重置位变换 (Fast Fourier Transform, FFT) 的重要算法。FFT 算法的第一步是对一维数组 $A[0..n-1]$ 执行一个称为位逆序置换 (bit-reversal permutation) 的操作，数组的长度 $n=2^k$，$k$ 是一个非负整数。这个置换操作下标的二进制数表示互为逆序的数组元素元素进行交换。

我们将每个下标 $a$ 表示为一个 $k$ 位二进制序列 $\langle a_{k-1}, a_{k-2}, \cdots, a_0 \rangle$，其中 $a = \sum_{i=0}^{k-1} a_i 2^i$。我们定义

$$
\text{rev}_x(\langle a_{k-1}, a_{k-2}, \cdots, a_0 \rangle) = \langle a_0, a_1, \cdots, a_{k-1} \rangle
$$

因此，

$$
\text{rev}_x(a) = \sum_{i=0}^{k-1} a_{k-i-1} 2^i
$$

例如，若 $n=16$（或等价地，$k=4$），则 $\text{rev}_4(3) = 12$，因为对应的 4 位二进制表示为 0011，其逆序为 12，是 12 的 位二进制表示。

a. 设计一个运行时间为 $\Theta(k)$ 的函数，编写算法在 $O(nk)$ 时间内长度为 $n=2^k$ 的数组执行位逆序置换。

b. 假定你的计算机的每个机器字保存有 $k$ 位二进制数，而一个机器字中的值进行一次任意位移量的左移位、右移位、位与、位或等操作只需单位时间。设计一个 BIT-REVERSED-INCREMENT 过程，能使一个 $k$ 元素的数组上的位逆序置换操作在 $O(n)$ 时间内完成。

c. 假定在单位时间内你只能完成右移一位的操作，还可做至多 $O(n)$ 时间的位逆序置换操作吗？

17-2 （动态二分查找）有序数组上的二分查找花费花费对数时间，但插入一个新元素的运行时间与数组规模线性相关。我们希望维护一个有序数组来提高插入性能。

具体地，假定我们希望支持 $n$ 元素上的 SEARCH 和 INSERT 操作。令 $k = \lceil\log(n+1)\rceil$，令 $n$ 的二进制表示为 $\langle n_{k-1}, n_{k-2}, \cdots, n_0 \rangle$，$n_i$ 表示第 $i$ 个有符号值 $a_i$。$A_1, \cdots, A_{n-1}$ 对 $n$ 个数组 $A_i$ 进行编号，取其 $n_i=1$ 还是 $n_i=0$。因此，所有 $k$ 个数组中保存的元素总数为 $\sum_{i=0}^{k} n_i 2^i = n$。虽然单独每个数组都是有序的，但不同数组中的元素之间不存在特定的大小关系。

a. 设计算法，实现这种数据结构上的 SEARCH 操作，分析其最坏情况运行时间。

b. 设计 INSERT 算法。分析最坏情况运行时间和摊还运行时间。

c. 讨论如何实现 DELETE。

17-3 （摊还加权平衡树）考虑扩充普通二叉搜索树，为每个结点 $x$ 增加属性 $x.size$，此属性给出 $x$ 的子树中关键字的数量。令 $a_1 \leqslant a_2 \leqslant \cdots \leqslant a_n$，我们称结点 $x$ 是 $\alpha$ 平衡的。如果树中每个结点都是 $\alpha$ 平衡的，则称树整体是 $\alpha$ 平衡的。G. Varghese 定义了一种树，其中每个结点维护计数器。

a. 在某种意义上，一棵 1/2 平衡树达到了极限平衡。给定任意一棵二叉搜索树，证明：如何重组以 $\alpha$ 为根的子树，使得它变为 1/2 平衡的树。你的算法的运行时间应该为 $\Theta(x.size)$，可以使用 $O(x.size)$ 的辅助空间。

b. 证明：对于任意一棵 $n$ 个结点的二叉搜索树，可以在 $O(n)$ 时间内执行一次搜索操作的执行时间为 $O(\log n)$。

c. 证明：对于本问题的剩余部分，假定常数 $\alpha$ 严格大于 1/2。假定你实现的 INSERT 和 DELETE 操作与普通二叉搜索树的 INSERT 和 DELETE 操作的算法是一样的。证明：如果发现树中任何结点不平衡的，则在最高的不平衡结点，对以它为根的子树执行“重建”，使得每个数组的元素总数为 $n/2$ 平衡的。

d. 假定 $m$ 个单位的势能够支持重建 $m$ 结点子树的代价，相对于 $m$ 个结点，$\alpha$ 应该多大才能使得重建一棵非 $\alpha$ 平衡的子树的摊还代价为 $O(1)$。

e. 证明：在棵 $n$ 结点的 $\alpha$ 平衡树中插入一个结点或删除一个结点所花时间为 $O(\log n)$。

$17$-$4$ （重构红黑树的代价） 红黑树有 $4$ 种基本的结构性修改（structural modification）操作：结点插入、结点删除、旋转及更改颜色。我们已经看到 RB-INSERT 和 RB-DELETE 操作仅使用 $O(1)$ 次旋转、结点插入和结点删除操作来维持红黑树的性质，但它们可能需要很多次更改颜色操作。

​	a. 设计一个 $n$ 结点的合法的红黑树，使得调用 RB-INSERT 添加第 $n+1$ 个结点会引起 $O(\log n)$ 次颜色更改。然后设计一个 $n$ 结点的合法的红黑树，使得调用 RB-DELETE 删除一个特定结点会引起 $O(\log n)$ 次颜色更改。

虽然每个操作所引起的颜色更改的最坏情况次数可能是对数的，但我们仍可以证明，在一个空红黑树上执行任意 $m$ 个 RB-INSERT 和 RB-DELETE 操作构成的序列，最坏情况下只会引起 $O(m)$ 次结构性修改。注意，我们将每次颜色更改计为一次结构性修改。

​	b. RB-INSERT-FIXUP 和 RB-DELETE-FIXUP 的代码的主循环都处理一些终结性的情况：一旦遇到这些情况，会导致循环在常数次操作后终止。对于 RB-INSERT-FIXUP 和 RB-DELETE-FIXUP 中处理的各种情况，指出其中哪些是终结性的，哪些不是。（提示：参见图 $13$-$5$、图 $13$-$6$ 和图 $13$-$7$。）

我们首先分析仅仅执行插入操作所引起的结构性修改。令 $T$ 为一棵红黑树，定义 $\Phi(T)$ 是 $T$ 中红结点数量。假定一个单位的势可以支付 RB-INSERT-FIXUP 的三种情况的任意一种所引起的结构性修改的代价。

​	c. 令 $T'$ 表示对 $T$ 应用 RB-INSERT-FIXUP 的情况 $1$ 得到的结果。证明：$\Phi(T') \leq \Phi(T) - 1$。

​	d. 当使用 RB-INSERT 向一棵红黑树中插入一个结点时，我们可以将操作分为三部分。列出 RB-INSERT 的第 $1$-$16$ 行引起的结构性改变和势的变化，以及 RB-INSERT-FIXUP 的非终结性情况引起的变化和势的变化。

​	e. 使用 (d) 证明：任意一次 RB-INSERT 执行所导致的结构性修改的摊还次数为 $O(1)$。我们现在希望证明既执行插入也执行删除时，所引起的结构性修改次数为 $O(m)$。对每个结点 $x$，我们定义

$$
w(x) = 
\begin{cases} 
0 & \text{若 } x \text{ 是红结点} \\
1 & \text{若 } x \text{ 是黑结点且没有红孩子} \\
2 & \text{若 } x \text{ 是黑结点且有一个红孩子} \\
3 & \text{若 } x \text{ 是黑结点且有两个红孩子}
\end{cases}
$$
现在定义红黑树 $T$ 的势函数为

$$
\Phi(T) = \sum_{x \in T} w(x)
$$
且令 $T'$ 为对 $T$ 应用 RB-INSERT-FIXUP 或 RB-DELETE-FIXUP 的任意非终结性情况后的结果。

​	f. 证明：对 RB-INSERT-FIXUP 的任意非终结性情况，有 $\Phi(T') \leq \Phi(T) - 1$。证明：INSERT-FIXUP 的任意一次调用所引起的结构性修改次数为 $O(1)$。

​	g. 证明：对 RB-DELETE-FIXUP 的任意非终结性情况，有 $\Phi(T') \leq \Phi(T) - 1$。证明：RB-DELETE-FIXUP 的任意一次调用所引起的结构性修改的次数为 $O(1)$。

​	h. 证明：任意 $m$ 个 RB-INSERT 和 RB-DELETE 操作构成的序列最坏情况下执行 $O(m)$ 次结构性修改。

$17$-$5$ （移至前端自组织列表的竞争优势） 自组织列表是 $n$ 个元素的链表，每个元素有一个唯一的关键字。当我们在列表中搜索元素时，需要给定一个关键字，我们搜索的是具有这个关键字的元素。

一个自组织列表有两个重要性质：

1. 为了在列表中查找一个元素，我们必须从表头开始遍历列表，直至遇到具有给定关键字的元素位置。如果此元素是列表的第 $k$ 个元素，则查找代价为 $k$。
2. 我们可以在任意一个操作后根据给定规则重排列表元素，产生一定的代价。我们可以使用任何我们喜欢的启发式策略来决定如何重排列表。

假定从一个给定的 $n$ 个元素的列表开始，并且给定了一个访问序列一关键字搜索序列 $\sigma=\left\langle\sigma_1,\sigma_1,\cdots,\sigma_n\right\rangle$ 。序列的代价是序列中单个访问的代价之和。

在多种可能的列表重排方法中，本问题关注相邻元素转置操作——交换相邻元素在列表中的位置，一次转置的代价为单位时间。你可以用势函数证明：针对移至前端列表的重排问题，一种特定的启发式策略的代价最坏情况也不会超过任何其他启发式策略的代价的 $4$ 倍，即使其他启发式策略预先知道访问序列！我们称这种分析为竞争分析。

对于一个启发式策略 $H$ 和列表的一个给定的初始顺序，我们将序列 $\sigma$ 的访问代价记为 $C_{H}(\sigma)$ 。令 $m$ 表示 $\sigma$ 中访问的数量。

​	a. 证明：若启发式策略 $H$ 预先不知道访问序列，那么利用 $H$ 来处理访问序列 $\sigma$ 的最坏情况代价为 $C_H(\sigma)=\Omega(m m)$ 。

当使用移至前端启发式策略时，搜索到元素 $x$ 后，我们将 $x$ 移动到列表的第一个位置(即列表的前端)。

令 $\operatorname{rank}_L(x)$ 表示元素 $x$ 在列表 $L$ 中的序号，即 $x$ 在 $L$ 中的位置。例如，若 $x$ 是 $L$ 中第 $4$ 个元素，那么 $\operatorname{rank}_k(x)=4$ 。令 $c_i$ 表示用移至前端策略处理访问 $\sigma_i$ 的代价，包括在列表中查找元素的代价和通过一系列相邻元素转置操作将其移至列表前端的代价。

​	b. 证明：如果 $\sigma_i$ 使用移至前端策略在 $L$ 中访问元素 $x$，则 $c_i=2\cdot\operatorname{rank}_t(x)-1$ 。

现在我们比较移至前端策略与其他任何按照上述两个性质处理访问序列的启发式策略 $H$ 。策略 $H$ 可能按任何它想用的方式转置列表中的元素，它甚至可能预先知道整个访问序列。序列。

令 $L_i$ 表示使用移至前端策略处理访问 $\sigma_i$ 后得到的列表， $L_i^{\prime}$ 表示使用策略 $H$ 后得到的列表。我们用 $c_i$ 表示移动前端策略的代价， $c_i$ 表示策略 $H$ 的代价。假定策略 $H$ 在处理访问 $\sigma_i$ 时执行 $t_i^{*}$ 次转置。

​	c. 在(b)中，你证明了 $c_i=2\cdot\operatorname{rank}_{L_{i-1}}(x)-1$ 。现在证明： $c_i^{\prime}=\operatorname{rank}_{L_{i-1}}(x)+t_i^{\prime}$ 。

我们定义逆序(inversion)关系： $L_i$ 中一对元素 $y$ 和 $z$，在 $L_i$ 中 $y$ 在 $z$ 之前，在 $L_i^*$ 中 $z$ 在 $y$ 之前。假定处理完访问序列 $\left\langle\sigma_1,\sigma_2,\cdots,\sigma_i\right\rangle, L_i$ 中有 $q_i$ 个逆序关系。然后，我们定义一个势函数，将 $L$ 映射到实数 $\Phi\left(L_1\right)=2 q_i$ 。例如，如果 $L_i$ 有元素 $\langle e, c, a, d, b\rangle$ ，而 $L_i^*$ 有元素 $\langle c, a, b, d, e\rangle$ ，那么 $L_i$ 有 $5$ 个逆序( $(e, c),(e, a),(e, d),(e, b),(e, b),(d, b))$,因此 $\Phi\left(L_i\right)=10$ 。观察到对所有 $i$，都有 $\Phi\left(L_i\right)\geqslant 0$ ，并且如果移至前端策略和策略 $H$ 从相同的列表 $L_0$ 开始，那么 $\Phi\left(L_0\right)=0$ 。

​	d. 证明：转置操作要么将势增加 $2$，要么减少 $2$。

假定访问 $\sigma_i$ 查找元素 $x$。为了理解势是如何根据 $\sigma_i$ 来变化的，我们将除 $x$ 之外的元素划分为 $4$ 个集合，划分的依据是在第 $i$ 次访问之前它们在列表中的位置：

● 集合 $A$ 包含在 $L_{i-1}$ 和 $L_{i-1}$ 中都位于 $x$ 之前的元素。

● 集合 $B$ 包含在 $L_{i-1}$ 中位于 $x$ 之前的元素，在 $L_{i-1}$ 中位于 $x$ 之后的元素。

● 集合 $C$ 包含在 $L_{r-1}$ 中位于 $x$ 之后的元素，在 $L_r$ ;中位于 $x$ 之前的元素。

● 集合 $D$ 包含在 $L_{i-1}$ 和 $L_{i-1}$ 中都位于 $x$ 之后的元素。

​	e. 证明： $\operatorname{rank}_{L_n}(x)=|A|+|B|+1$ 且 $\operatorname{rank}_{L_n}(x)=|A|+|C|+1$ 。

​	f. 证明：处理访问 $\sigma_i$ 会引起势的变化

$$
\Phi\left(L_1\right)-\Phi\left(L_{r-1}\right)\leqslant 2\left(|A|-|B|+t_1^*\right)
$$

其中，表示用启发式策略 $H$ 处理访问 $\sigma_i$ 期间执行的转置操作次数。

我们定义处理访问 $\sigma_i$ 的摊还代价为 $\hat{c}_i=c_i+\Phi\left(L_i\right)-\Phi\left(L_{i-1}\right)$ 。

​	g. 证明：处理访问 $\sigma_i$ 的摊还代价的上界为 $4 c_i^{*}$ 。

​	h. 证明：使用移至前端策略处理访问序列 $\sigma$ 的代价 $C_{MTF}(\sigma)$ 至多是用其他任何启发式策略 $H$ 处理 $\sigma$ 的代价 $C_H(\sigma)$ 的 $4$ 倍，假定两种启发式策略都是从相同的列表开始处理访问序列。

